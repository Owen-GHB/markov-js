// File: cli\CLI.js

import { formatResult } from '../shared/format.js';

export class CLI {
	constructor(config, commandProcessor) {
		if (!config || typeof config !== 'object') {
			throw new Error('CLI requires a config object');
		}

		// Extract paths from nested config object
		const paths = config.paths || {};

		if (!paths.contextFilePath) {
			throw new Error(
				'CLI config requires paths with contextFilePath property',
			);
		}

		if (
			!commandProcessor ||
			typeof commandProcessor.processCommand !== 'function'
		) {
			throw new Error(
				'start method requires a valid commandProcessor with processCommand method',
			);
		}
		this.processor = commandProcessor;
		this.contextFilePath = paths.contextFilePath;
		if (this.contextFilePath) this.processor.stateManager.loadState(this.contextFilePath);
	}

	/**
	 * Run the CLI with provided arguments
	 * @param {string[]} args - Command line arguments
	 */
	async run(args) {
		if (args.length === 0) {
			// Show help when no arguments provided by processing the help command
			const result = await this.processor.processCommand(
				'help()',
				this.contextFilePath,
			);

			if (result.error) {
				console.error(`‚ùå ${result.error}`);
				process.exit(1);
			}

			if (result.output) {
				console.log(formatResult(result.output));
			}
			process.exit(0);
		}

		// Join all arguments into a single command string for parsing
		const input = args.join(' ');

		// Process the command using the shared processor
		const result = await this.processor.processCommand(
			input,
			this.contextFilePath,
		);

		if (result.error) {
			console.error(`‚ùå ${result.error}`);
			// Show help on error
			const helpResult = await this.processor.processCommand(
				'help()',
				this.contextFilePath,
			);
			if (helpResult.output) {
				console.log(formatResult(helpResult.output));
			}
			process.exit(1);
		}

		if (result.output) {
			console.log(formatResult(result.output));
		}

		// Check if the command requested exit
		if (result.exit) {
			process.exit(0);
		}
	}

	/**
	 * Show help information
	 */
	async showHelp() {
		const result = await this.processor.processCommand(
			'help()',
			this.contextFilePath,
		);
		if (result.output) {
			console.log(formatResult(result.output));
		}
	}
}

// The CLI class now requires paths to be passed in, so direct execution from this file
// is not possible without the path resolver. This functionality would need to be handled
// by the main application which has access to the path resolver.


================================================================================

<!-- File: cli\config.json -->

{
	"paths": {
		"contextFilePath": "context/state.json"
	}
}

================================================================================

// File: cli\index.js

import { CLI } from './CLI.js';

/**
 * CLI plugin wrapper
 * Encapsulates the CLI plugin instantiation and exposes functional interface
 */

// Plugin instance (singleton)
let cliInstance = null;

/**
 * Initialize and get the CLI instance
 * @param {Object} config - Configuration object
 * @returns {CLI} CLI plugin instance
 */
function getCliInstance(config, commandProcessor) {
	if (!cliInstance) {
		cliInstance = new CLI(config, commandProcessor);
	}
	return cliInstance;
}

/**
 * Run the CLI plugin
 * @param {Object} config - Configuration object
 * @param {Object} commandProcessor - Command processor instance
 * @param {string[]} args - Command line arguments
 * @returns {Promise<void>}
 */
export async function run(config, commandProcessor, args) {
	const cli = getCliInstance(config, commandProcessor);
	return await cli.run(args);
}

/**
 * Expose the plugin's run method for direct usage
 */
export default {
	run,
};


================================================================================

<!-- File: electron\config.json -->

{
	"paths": {
		"servedUIDir": "generated-ui",
		"electronPreloadPath": "electron-preload.js"
	}
}


================================================================================

// File: electron\electron-main.js

import { ElectronApp } from './ElectronApp.js';
import { KernelLoader } from './KernelLoader.js';

// Parse command line arguments to get project root and kernel path
const args = process.argv.slice(2);
const argMap = {};
for (let i = 0; i < args.length; i += 2) {
	if (args[i].startsWith('--')) {
		const key = args[i].substring(2);
		const value = args[i + 1];
		argMap[key] = value;
	}
}

const projectRoot = argMap['project-root'];
const kernelPath = argMap['kernel-path'];

if (!projectRoot || !kernelPath) {
	console.error(
		'‚ùå Missing required arguments: --project-root and --kernel-path',
	);
	process.exit(1);
}

// Create and start the Electron application by dynamically loading kernel modules
(async () => {
	try {
		// Create kernel loader with the provided paths
		const kernelLoader = new KernelLoader(kernelPath, projectRoot);

		// Build configuration dynamically
		const config = await kernelLoader.buildConfig();

		// Get manifest dynamically
		const manifest = await kernelLoader.getManifest(
			config.paths.contractDir,
			projectRoot,
		);

		// Create CommandProcessor dynamically
		const commandProcessor = await kernelLoader.createCommandProcessor(
			config,
			manifest,
		);

		// Directly instantiate and start ElectronApp with the dynamically created components
		const electronApp = new ElectronApp();

		await electronApp.start(config, commandProcessor);
	} catch (error) {
		console.error('‚ùå Error in Electron main process:', error.message);
		process.exit(1);
	}
})();


================================================================================

// File: electron\ElectronApp.js

import { app, BrowserWindow, ipcMain } from 'electron';
import fs from 'fs';
import path from 'path';

/**
 * Manages the UI for the Electron application, including checking and loading
 */
class ElectronUIManager {
	/**
	 * Check if the served UI directory exists and has required files
	 * @param {string} filename - The UI filename to check (default: 'index.html')
	 * @param {Object} paths - Paths object containing required paths
	 * @returns {boolean} True if the served UI directory exists and has the file
	 */
	hasServedUI(filename = 'index.html', paths = {}) {
		const servedDir = paths.servedUIDir;
		const indexPath = path.join(servedDir, filename);
		return fs.existsSync(servedDir) && fs.existsSync(indexPath);
	}

	/**
	 * Get the UI file path from the served UI directory
	 * @param {string} filename - The UI filename (default: 'index.html')
	 * @param {Object} paths - Paths object containing required paths
	 * @returns {string} The path to the UI file
	 */
	getUIPath(filename = 'index.html', paths = {}) {
		const servedDir = paths.servedUIDir;
		return path.join(servedDir, filename);
	}
}

/**
 * Handles commands for the Electron application via IPC
 */
class ElectronCommandHandler {
	constructor(config, commandProcessor) {
		this.commandProcessor = commandProcessor;
	}

	/**
	 * Execute a command through the kernel
	 * @param {Object} command - The command to execute
	 * @returns {Promise<Object>} - The result of the command execution
	 */
	async executeCommand(command) {
		try {
			// The command from UI is already parsed as an object
			// We'll pass it through the processor to handle state management properly
			// Convert command object to expected format for processCommand if needed
			const commandString = JSON.stringify(command);
			const result = await this.commandProcessor.processCommand(commandString);
			return result;
		} catch (error) {
			return { error: error.message, output: null };
		}
	}
}

export class ElectronApp {
	constructor(options = {}) {
		this.uiManager = new ElectronUIManager();
		this.commandHandler = null; // Will be initialized in start method
		this.options = options;
		this.windowOptions = {
			width: options.width || 1200,
			height: options.height || 800,
			webPreferences: {
				nodeIntegration: false,
				contextIsolation: true,
				preload: options.preloadPath || null, // Will be set in start method
			},
			...options.windowOptions,
		};
		this.showDevTools = options.showDevTools !== false; // Default to true unless explicitly disabled
	}

	createWindow() {
		const mainWindow = new BrowserWindow(this.windowOptions);

		// Check if UI exists first, refuse to work if not
		if (!this.uiManager.hasServedUI('index.html', this.paths)) {
			console.error(
				"UI files not found. Please generate UI files first using 'node kernel.js --generate'",
			);
			// Show error and close the window
			mainWindow.loadURL(
				`data:text/html,<h1>UI Files Not Found</h1><p>Please generate UI files first using 'node kernel.js --generate'</p><p>The Electron app will close in 5 seconds.</p>`,
			);

			// Close the window after a delay to let the user see the error
			setTimeout(() => {
				mainWindow.close();
				if (BrowserWindow.getAllWindows().length === 0) {
					app.quit();
				}
			}, 5000);

			return mainWindow;
		}

		// Load the UI from the served UI directory
		try {
			const uiPath = this.uiManager.getUIPath('index.html', this.paths);
			// Load the generated UI
			mainWindow.loadFile(uiPath);
		} catch (err) {
			console.error('Failed to load UI:', err);
			// Load an error page
			mainWindow.loadURL(
				`data:text/html,<h1>UI Loading Failed</h1><p>${err.message}</p>`,
			);
		}

		// Open the DevTools if specified
		if (this.showDevTools) {
			mainWindow.webContents.openDevTools();
		}

		return mainWindow;
	}

	setupIPC() {
		// IPC handler to execute commands via the kernel
		ipcMain.handle('execute-command', async (event, command) => {
			return await this.commandHandler.executeCommand(command);
		});
	}

	async start(config = {}, commandProcessor) {
		// Validate config object
		if (typeof config !== 'object' || config === null) {
			throw new Error('config parameter must be an object');
		}

		if (
			!commandProcessor ||
			typeof commandProcessor.processCommand !== 'function'
		) {
			throw new Error(
				'start method requires a valid commandProcessor with processCommand method',
			);
		}

		// Extract paths from nested config object
		const paths = config.paths || {};

		// Check if required paths are provided
		if (!paths.electronPreloadPath) {
			console.warn('‚ö†Ô∏è electronPreloadPath not provided');
		}

		// Store paths for use by UI manager methods
		this.paths = paths;

		// Initialize command handler with unified config
		this.commandHandler = new ElectronCommandHandler(config, commandProcessor);

		// Use provided config with potential defaults
		const effectiveConfig = { ...config };

		// Cache path resolver value at the beginning of start method
		const preloadPath = paths.electronPreloadPath;

		// Update the preload path in webPreferences
		this.windowOptions.webPreferences.preload =
			this.options.preloadPath || preloadPath;

		// Ensure preload script exists
		if (
			this.windowOptions.webPreferences.preload &&
			!fs.existsSync(this.windowOptions.webPreferences.preload)
		) {
			console.error(
				`Preload script not found at: ${this.windowOptions.webPreferences.preload}`,
			);
			console.error('This may cause IPC to not work properly.');
		}

		this.setupIPC();

		// This method will be called when Electron has finished
		// initialization and is ready to create browser windows.
		app.whenReady().then(() => {
			this.createWindow();

			app.on('activate', () => {
				// On macOS it's common to re-create a window in the app when the
				// dock icon is clicked and there are no other windows open.
				if (BrowserWindow.getAllWindows().length === 0) {
					this.createWindow();
				}
			});
		});

		// Quit when all windows are closed, except on macOS. There, it's common
		// for applications and their menu bar to stay active until the user quits
		// explicitly with Cmd + Q.
		app.on('window-all-closed', () => {
			if (process.platform !== 'darwin') {
				app.quit();
			}
		});
	}
}


================================================================================

// File: electron\index.js

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Start the Electron plugin by launching electron-main.js via npx
 * @param {Object} config - Configuration object (contains paths information)
 * @param {Object} commandProcessor - Command processor instance (not used directly, as electron-main.js recreates kernel)
 * @returns {Promise<void>}
 */
export async function start(config, commandProcessor) {
	// Since Electron needs to be launched as a separate process, we spawn electron using npx
	// which will run electron-main.js. The electron-main.js will now use dynamic kernel loading.
	return import('child_process')
		.then(({ spawn }) => {
			// Get the project root and kernel path from the config
			const projectRoot = process.cwd(); // Use current working directory as project root
			const kernelDir = config.paths?.kernelDir;
			if (!kernelDir) {
			throw new Error('kernelDir must be provided in config.paths by the path resolver');
			}


			// Launch electron with the electron-main.js file and pass the required paths as arguments
			const electronMainPath = path.join(__dirname, 'electron-main.js');
			const npxProcess = spawn(
				'npx',
				[
					'electron',
					electronMainPath,
					'--project-root',
					projectRoot,
					'--kernel-path',
					kernelDir,
				],
				{
					stdio: 'inherit',
					cwd: projectRoot, // Crucial: run from project root
					shell: true,
				},
			);

			npxProcess.on('error', (err) => {
				console.error('‚ùå Failed to start Electron:', err.message);
				console.log(
					'Make sure you have installed Electron as a dev dependency: npm install --save-dev electron',
				);
				process.exit(1);
			});

			npxProcess.on('close', (code) => {
				console.log(`Electron process exited with code ${code}`);
				process.exit(code);
			});
		})
		.catch((err) => {
			console.error('‚ùå Failed to launch Electron:', err.message);
			process.exit(1);
		});
}

/**
 * Expose the plugin's start method for direct usage
 */
export default {
	start,
};


================================================================================

// File: electron\KernelLoader.js

import path from 'path';
import { pathToFileURL } from 'url';

/**
 * KernelLoader - Dynamically loads kernel modules using provided paths
 */
export class KernelLoader {
	constructor(kernelPath, projectRoot) {
		this.kernelPath = kernelPath;
		this.projectRoot = projectRoot;
	}

	/**
	 * Dynamically import a kernel module
	 * @param {string} modulePath - Path relative to the kernel directory (e.g., 'utils/config-loader.js')
	 * @returns {Promise<Object>} - The imported module
	 */
	async importKernelModule(modulePath) {
		const fullPath = path.join(this.kernelPath, modulePath);
		const moduleUrl = pathToFileURL(fullPath).href;
		return await import(moduleUrl);
	}

	/**
	 * Builds the configuration using the dynamic config loader
	 * @returns {Promise<Object>} - The built configuration
	 */
	async buildConfig() {
		const { buildConfig } = await this.importKernelModule(
			'utils/config-loader.js',
		);
		const configFilePath = path.join(this.kernelPath, 'config.json');
		return buildConfig(configFilePath, this.projectRoot);
	}

	/**
	 * Gets the manifest using the dynamic contract loader
	 * @param {string} contractDir - The contract directory path
	 * @param {string} projectRoot - The project root path
	 * @returns {Promise<Object>} - The manifest
	 */
	async getManifest(contractDir, projectRoot) {
		const { manifestReader } = await this.importKernelModule('contract.js');
		return manifestReader(contractDir, projectRoot);
	}

	/**
	 * Creates a CommandProcessor instance using dynamically loaded modules
	 * @param {Object} config - The configuration object
	 * @param {Object} manifest - The manifest object
	 * @returns {Promise<Object>} - The CommandProcessor instance
	 */
	async createCommandProcessor(config, manifest) {
		const { CommandProcessor } = await this.importKernelModule(
			'processor/CommandProcessor.js',
		);
		return new CommandProcessor(config, manifest);
	}
}


================================================================================

<!-- File: generate-html\config.json -->

{
	"paths": {
		"userTemplateDir": "ejs-templates",
		"generatedUIDir": "generated-ui"
	}
}

================================================================================

// File: generate-html\index.js

import { UI } from './UI.js';

/**
 * EJS-based Generator plugin wrapper
 * Encapsulates the EJS generator plugin instantiation and exposes functional interface
 */

// Plugin instance (singleton)
let generatorInstance = null;

/**
 * Initialize and get the generator instance
 * @returns {UI} Generator plugin instance
 */
function getGeneratorInstance() {
	if (!generatorInstance) {
		generatorInstance = new UI();
	}
	return generatorInstance;
}

/**
 * Run the EJS-based generator plugin
 * @param {Object} config - Configuration object
 * @param {Object} manifest - Manifest object
 * @param {Object} commandProcessor - CommandProcessor instance
 * @returns {Promise<void>}
 */
export async function run(config, manifest, commandProcessor) {
	const generator = getGeneratorInstance();
	return await generator.run(config, manifest, commandProcessor);
}

/**
 * Expose the plugin's run method for direct usage
 */
export default {
	run,
};

================================================================================

// File: generate-html\UI.js

// File: UI.js

import fs from 'fs';
import path from 'path';
import ejs from 'ejs';
import { fileURLToPath } from 'url';

/**
 * Main EJS-based UI Generator class that creates a complete SPA from contract manifests
 */
export class UI {
    constructor() {
        this.__dirname = path.dirname(fileURLToPath(import.meta.url));
    }

    /**
     * Generate the complete SPA from manifests using EJS templates
     * @param {Object} config - Configuration object containing paths and settings
     * @param {Object} manifest - The contract manifest with global and command information
     */
	async run(config, manifest) {
		try {
			const outputDir = config.paths.generatedUIDir;
			
			// First try user templates, fall back to built-in templates
			let templateDir;
			if (config.paths.userTemplateDir && fs.existsSync(config.paths.userTemplateDir)) {
				templateDir = config.paths.userTemplateDir;
				console.log(`Using user templates from: ${templateDir}`);
			} else {
				// Fall back to built-in templates
				templateDir = path.resolve(this.__dirname, 'templates');
				console.log(`Using built-in templates from: ${templateDir}`);
				
				// Verify built-in templates exist
				if (!fs.existsSync(templateDir)) {
					throw new Error(
						`Built-in templates directory not found: ${templateDir}. Please ensure the templates are included with the generator.`
					);
				}
			}

			console.log('Starting EJS-based UI generation...');

			// Use the provided manifest directly
			const globalManifest = manifest;
			const commandManifests = manifest.commands || [];
			console.log(
				`Processing manifest with ${commandManifests.length} command manifests`
			);

			// Ensure output directory exists and is empty
			if (fs.existsSync(outputDir)) {
				console.log(`Emptying output directory: ${outputDir}`);
				this.emptyDirectory(outputDir);
			} else {
				fs.mkdirSync(outputDir, { recursive: true });
			}

			// Generate all command forms using EJS templates
			const commandForms = await this.generateCommandForms(
				commandManifests, 
				globalManifest, 
				templateDir
			);

			// Generate the main SPA using EJS template
			await this.generateSPA(
				globalManifest,
				commandManifests,
				commandForms,
				outputDir,
				templateDir
			);

			// Generate client-side JavaScript
			await this.generateClientSideJavaScript(
				globalManifest,
				commandManifests,
				outputDir,
				templateDir
			);

			// Copy CSS file
			await this.copyCSSFile(templateDir, outputDir);

			console.log(`EJS-based UI generated successfully at: ${outputDir}`);
			console.log('UI generation completed!');

		} catch (error) {
			console.error('Error during EJS-based UI generation:', error);
			throw error;
		}
	}

    /**
     * Generate all command forms using EJS templates
     * @param {Array} commandManifests - Array of command manifests
     * @param {Object} globalManifest - Global manifest for state defaults
     * @param {string} templateDir - Path to templates directory
     * @returns {Promise<Array>} Array of rendered command form HTML
     */
    async generateCommandForms(commandManifests, globalManifest, templateDir) {
        const commandForms = [];
        const initialState = globalManifest.stateDefaults || {};

        for (const command of commandManifests) {
            try {
                const formHtml = await this.renderCommandForm(
                    command, 
                    initialState, 
                    templateDir
                );
                commandForms.push(formHtml);
            } catch (error) {
                console.error(`Error generating form for command ${command.name}:`, error);
                throw error;
            }
        }

        return commandForms;
    }

    /**
     * Render a single command form using EJS template
     * @param {Object} command - Command manifest
     * @param {Object} state - Current state for runtime fallbacks
     * @param {string} templateDir - Path to templates directory
     * @returns {Promise<string>} Rendered HTML for the command form
     */
    async renderCommandForm(command, state, templateDir) {
        const formTemplatePath = path.join(templateDir, 'command-form.ejs');
        
        if (!fs.existsSync(formTemplatePath)) {
            throw new Error(`Command form template not found: ${formTemplatePath}`);
        }

        const template = fs.readFileSync(formTemplatePath, 'utf8');
        
        // Generate parameter fields for this command
        const parameterFields = await this.generateParameterFields(command, state, templateDir);

        const data = {
            command: command,
            parameterFields: parameterFields,
            formSubmitButton: 'Execute Command'
        };

        return ejs.render(template, data);
    }

    /**
     * Generate parameter fields for a command using EJS template
     * @param {Object} command - Command manifest
     * @param {Object} state - Current state for runtime fallbacks
     * @param {string} templateDir - Path to templates directory
     * @returns {Promise<string>} Rendered HTML for all parameter fields
     */
    async generateParameterFields(command, state, templateDir) {
        const paramTemplatePath = path.join(templateDir, 'param-field.ejs');
        
        if (!fs.existsSync(paramTemplatePath)) {
            throw new Error(`Parameter field template not found: ${paramTemplatePath}`);
        }

        const template = fs.readFileSync(paramTemplatePath, 'utf8');
        let allParameterFields = '';

        for (const paramName in command.parameters || {}) {
            const param = command.parameters[paramName];
            param.name = paramName; // Ensure name is available
            
            // Calculate default value considering runtime fallbacks
            const defaultValue = this.getParameterDefaultValue(param, state);

            const data = {
                param: param,
                defaultValue: defaultValue
            };

            const fieldHtml = ejs.render(template, data);
            allParameterFields += fieldHtml;
        }

        return allParameterFields;
    }

    /**
     * Get default value for a parameter considering runtime fallbacks
     * @param {Object} param - Parameter definition
     * @param {Object} state - Current state object
     * @returns {any} Default value
     */
    getParameterDefaultValue(param, state) {
        // First check for runtime fallback
        if (param.runtimeFallback && state && state[param.runtimeFallback] !== undefined) {
            return state[param.runtimeFallback];
        }

        // Otherwise use default from manifest
        if (param.default !== undefined) {
            return param.default;
        }

        return undefined;
    }

    /**
     * Generate the main SPA HTML using EJS template
     * @param {Object} globalManifest - Global manifest
     * @param {Array} commandManifests - Array of command manifests
     * @param {Array} commandForms - Array of rendered command form HTML
     * @param {string} outputDir - Output directory
     * @param {string} templateDir - Templates directory
     */
    async generateSPA(globalManifest, commandManifests, commandForms, outputDir, templateDir) {
        const baseTemplatePath = path.join(templateDir, 'spa-base.ejs');
        
        if (!fs.existsSync(baseTemplatePath)) {
            throw new Error(`SPA base template not found: ${baseTemplatePath}`);
        }

        const template = fs.readFileSync(baseTemplatePath, 'utf8');

        const data = {
            htmlTitle: globalManifest.name || 'Command Interface',
            pageHeader: globalManifest.description || 'Command Interface',
            commandSelectorLabel: 'Select Command:',
            commands: commandManifests,
            commandForms: commandForms.join('\n')
        };

        const renderedHtml = ejs.render(template, data);
        const htmlFilePath = path.join(outputDir, 'index.html');
        fs.writeFileSync(htmlFilePath, renderedHtml);
        
        console.log(`Generated main SPA: ${htmlFilePath}`);
    }

    /**
     * Generate client-side JavaScript file
     * @param {Object} globalManifest - Global manifest
     * @param {Array} commandManifests - Array of command manifests
     * @param {string} outputDir - Output directory
	 * @param {string} templateDir - Templates directory
     */
	async generateClientSideJavaScript(globalManifest, commandManifests, outputDir, templateDir) {
		const jsTemplatePath = path.join(templateDir, 'app.js.ejs');
		
		if (!fs.existsSync(jsTemplatePath)) {
			throw new Error(`JavaScript template not found: ${jsTemplatePath}`);
		}

		const template = fs.readFileSync(jsTemplatePath, 'utf8');
		
		const data = {
			initialState: globalManifest.stateDefaults || {},
			commands: commandManifests
		};

		const renderedJS = ejs.render(template, data);
		const jsFilePath = path.join(outputDir, 'app.js');
		fs.writeFileSync(jsFilePath, renderedJS);
		
		console.log(`Generated client-side JavaScript: ${jsFilePath}`);
	}

    /**
     * Copy CSS file to output directory
     * @param {string} templateDir - Templates directory
     * @param {string} outputDir - Output directory
     */
    async copyCSSFile(templateDir, outputDir) {
        const cssSourcePath = path.join(templateDir, 'global.css');
        const cssDestPath = path.join(outputDir, 'app.css');
        
        if (fs.existsSync(cssSourcePath)) {
            fs.copyFileSync(cssSourcePath, cssDestPath);
            console.log(`Copied CSS file: ${cssDestPath}`);
        } else {
            console.warn(`CSS file not found at: ${cssSourcePath}`);
        }
    }

    /**
     * Empty a directory by removing all files and subdirectories
     * @param {string} dirPath - Path to the directory to empty
     */
    emptyDirectory(dirPath) {
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const itemPath = path.join(dirPath, item);
            const stat = fs.statSync(itemPath);
            
            if (stat.isDirectory()) {
                this.emptyDirectory(itemPath);
                fs.rmdirSync(itemPath);
            } else {
                fs.unlinkSync(itemPath);
            }
        }
    }
}

================================================================================

<!-- File: generate-html\templates\app.js.ejs -->

// File: templates/app.js.ejs

// Client-side JavaScript for EJS-generated UI
(function() {
    'use strict';
    
    // Initialize state from global defaults
    let state = <%- JSON.stringify(initialState, null, 2) %>;
    
    // Available commands
    const commands = <%- JSON.stringify(commands, null, 2) %>;
    
    // Map of command manifests by name for quick lookup
    const commandManifests = {};
    commands.forEach(cmd => {
        commandManifests[cmd.name] = cmd;
    });
    
    // DOM elements
    const commandSelector = document.getElementById('commandSelector');
    const formsContainer = document.getElementById('formsContainer');
    const resultsContainer = document.getElementById('resultsContainer');
    const resultsContent = document.getElementById('resultsContent');
    
    // Show a specific form and hide others
    function showForm(commandName) {
        // Hide all forms
        document.querySelectorAll('.form-container').forEach(form => {
            form.classList.remove('active-form');
        });
        
        // Show the selected form if it exists
        if (commandName) {
            const form = document.getElementById(commandName + '-form');
            if (form) {
                form.classList.add('active-form');
            }
        }
    }
    
    // Handle command selection change
    commandSelector.addEventListener('change', function(e) {
        const commandName = e.target.value;
        showForm(commandName);
        
        // Scroll to the form
        if (commandName) {
            const form = document.getElementById(commandName + '-form');
            if (form) {
                form.scrollIntoView({ behavior: 'smooth' });
            }
        }
    });
    
    // Handle form submissions
    document.addEventListener('submit', function(e) {
        if (e.target.classList.contains('command-form')) {
            e.preventDefault();
            handleCommandSubmit(e.target);
        }
    });
    
    // Process a command form submission
    async function handleCommandSubmit(form) {
        const commandName = form.getAttribute('data-command');
        if (!commandName) return;
        
        const cmdManifest = commandManifests[commandName];
        if (!cmdManifest) {
            showResults({ error: 'Command not found: ' + commandName }, 'error');
            return;
        }
        
        // Extract form data
        const args = {};
        const paramManifests = cmdManifest.parameters || {};
        
        for (const paramName in paramManifests) {
            const param = paramManifests[paramName];
            param.name = paramName;
            
            // Find the field within the current form
            const field = form.querySelector('[data-param-name="' + param.name + '"]');
            let value;
            
            if (field) {
                // Extract value from the form field
                if (field.type === 'checkbox') {
                    value = field.checked;
                } else if (field.type === 'number') {
                    value = field.value ? Number(field.value) : (param.required ? 0 : undefined);
                } else if (field.type === 'select-multiple') {
                    // Handle multi-select
                    const selectedOptions = Array.from(field.selectedOptions);
                    value = selectedOptions.map(option => option.value);
                } else {
                    value = field.value !== undefined ? field.value : (field.textContent || field.innerText);
                    
                    // Handle array inputs (comma-separated values)
                    if (param.type === 'array' && value) {
                        value = value.split(',').map(v => v.trim()).filter(v => v);
                    }
                }
            }
            
            // Apply runtime fallback only if the field value is empty/undefined and a fallback exists
            if ((value === undefined || value === '' || value === null) && param.runtimeFallback && state[param.runtimeFallback] !== undefined) {
                value = state[param.runtimeFallback];
            }
            
            // For checkboxes, we should always include the value (true/false), otherwise only add to args if value exists and is not empty
            if (field && field.type === 'checkbox') {
                args[param.name] = value || false;
            } else if (value !== undefined && value !== '' && value !== null) {
                args[param.name] = value;
            }
        }
        
        // Prepare command object
        const command = {
            name: commandName,
            args: args
        };
        
        console.log('Executing command:', command);
        
        try {
            // Execute the command
            const result = await executeCommand(command);
            
            // Update state based on side effects
            state = updateState(state, command, result, cmdManifest);
            
            // Show results
            showResults(result, result.error ? 'error' : 'success');
        } catch (error) {
            showResults({ error: 'Execution Error: ' + error.message }, 'error');
        }
    }
    
    // Validate a command (simplified - would use actual validation in real implementation)
    function validateCommand(command, cmdManifest) {
        return {
            isValid: true,
            errors: []
        };
    }
    
    // Update state based on command side effects (simplified)
    function updateState(state, command, result, cmdManifest) {
        // This is a simplified version - in a real implementation, 
        // you would use proper state management
        return Object.assign({}, state);
    }
    
    // API execution function that makes HTTP requests or uses Electron IPC
    async function executeCommand(command) {
        // More thorough check for Electron environment
        const isElectron = window && window.electronAPI && typeof window.electronAPI.executeCommand === 'function';
        
        if (isElectron) {
            // Use IPC to send command to main process
            try {
                const result = await window.electronAPI.executeCommand(command);
                return result;
            } catch (error) {
                // Fallback to HTTP if IPC fails
            }
        }
        
        // Make HTTP API call to the /api endpoint (default behavior if not in Electron or if IPC failed)
        try {
            // First, try POST request with JSON body
            const response = await fetch('/api', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    json: JSON.stringify(command)
                })
            });
            
            if (!response.ok) {
                let errorText = 'HTTP Error: ' + response.status;
                try {
                    const errorData = await response.json();
                    if (errorData.error) {
                        errorText = errorData.error;
                    }
                } catch (e) {
                    errorText = response.statusText || errorText;
                }
                throw new Error(errorText);
            }
            
            const result = await response.json();
            return result;
        } catch (postError) {
            // If POST fails, try GET request as fallback
            try {
                const urlParams = new URLSearchParams({
                    json: JSON.stringify(command)
                });
                
                const response = await fetch('/api?' + urlParams.toString());
                
                if (!response.ok) {
                    let errorText = 'HTTP Error: ' + response.status;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) {
                            errorText = errorData.error;
                        }
                    } catch (e) {
                        errorText = response.statusText || errorText;
                    }
                    throw new Error(errorText);
                }
                
                const result = await response.json();
                return result;
            } catch (getError) {
                throw getError;
            }
        }
    }
    
    // Show results in the results container
    function showResults(result, type = 'success') {
        resultsContainer.classList.remove('hidden', 'error', 'success');
        
        // Determine the appropriate type and content to display
        if (result.error) {
            resultsContainer.classList.add('error');
            resultsContent.innerHTML = '<strong>Error:</strong><br><code>' + escapeHtml(result.error) + '</code>';
        } else if (result.output) {
            resultsContainer.classList.add('success');
            // Format output, handling newlines properly
            let formattedOutput = escapeHtml(result.output).replace(/\n/g, '<br>');
            resultsContent.innerHTML = '<strong>Output:</strong><br><code>' + formattedOutput + '</code>';
        } else {
            // If no specific error or output, show the full result for debugging
            resultsContainer.classList.add(type);
            resultsContent.innerHTML = '<pre>' + JSON.stringify(result, null, 2) + '</pre>';
        }
    }
    
    // Escape HTML special characters to prevent XSS
    function escapeHtml(str) {
        if (typeof str !== 'string') return String(str);
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    
    // Initialize - hide all forms initially
    showForm('');
    
    console.log('EJS-generated UI initialized with', commands.length, 'commands');
})();

================================================================================

<!-- File: generate-html\templates\command-form.ejs -->

<div
	id="<%= command.name %>-form"
	class="form-container"
	data-command-form="<%= command.name %>"
>
	<h2><%= command.name %></h2>
	<p><%= command.description || '' %></p>

	<form class="command-form" data-command="<%= command.name %>">
		<%- parameterFields %>

		<button type="submit" class="btn btn-block"><%= formSubmitButton || 'Execute Command' %></button>
	</form>

	<% if (command.examples && command.examples.length > 0) { %>
		<div class="command-examples">
			<h4>Examples:</h4>
			<ul>
				<% command.examples.forEach(function(example) { %>
					<li><pre><code><%- example %></code></pre></li>
				<% }); %>
			</ul>
		</div>
	<% } %>
</div>

================================================================================

<!-- File: generate-html\templates\global.css -->

:root {
	--primary-color: #3498db;
	--secondary-color: #2c3e50;
	--success-color: #27ae60;
	--warning-color: #f39c12;
	--danger-color: #e74c3c;
	--light-color: #f8f9fa;
	--dark-color: #343a40;
	--border-color: #ddd;
	--shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
	line-height: 1.5;
	color: #333;
	background-color: #f5f7fa;
	padding: 10px;
}

.container {
	max-width: 1200px;
	margin: 0 auto;
	background: white;
	border-radius: 6px;
	box-shadow: var(--shadow);
	overflow: hidden;
}

header {
	background: var(--secondary-color);
	color: white;
	padding: 12px 15px;
	text-align: center;
}

header h1 {
	margin-bottom: 3px;
	font-size: 1.4em;
}

.main-content {
	display: flex;
	flex-direction: column;
	padding: 12px;
}

@media (min-width: 768px) {
	.main-content {
		flex-direction: row;
	}
}

.sidebar {
	width: 100%;
	padding: 12px;
	border-right: 1px solid var(--border-color);
	margin-bottom: 12px;
}

@media (min-width: 768px) {
	.sidebar {
		width: 220px;
		margin-bottom: 0;
	}
}

.content {
	flex: 1;
	padding: 12px;
}

.command-selector {
	width: 100%;
	padding: 8px;
	border: 1px solid var(--border-color);
	border-radius: 4px;
	background: white;
	font-size: 14px;
}

.form-container {
	display: none;
}

.form-container.active-form {
	display: block;
}

.form-group {
	margin-bottom: 12px;
}

label {
	display: block;
	margin-bottom: 4px;
	font-weight: bold;
	color: var(--secondary-color);
	font-size: 0.95em;
}

.param-description {
	display: block;
	font-weight: normal;
	font-size: 0.85em;
	color: #666;
	margin-top: 1px;
}

input,
select,
textarea {
	width: 100%;
	padding: 7px 8px;
	border: 1px solid var(--border-color);
	border-radius: 4px;
	font-size: 14px;
}

input[type='checkbox'] {
	width: auto;
	margin-right: 5px;
}

textarea {
	min-height: 80px;
	resize: vertical;
}

.validation-info {
	font-size: 0.8em;
	color: #666;
	margin-top: 3px;
}

.array-format-help,
.union-type-help {
	font-size: 0.8em;
	color: #666;
	margin-top: 3px;
	font-style: italic;
}

.btn {
	display: inline-block;
	padding: 8px 16px;
	background: var(--primary-color);
	color: white;
	border: none;
	border-radius: 4px;
	cursor: pointer;
	font-size: 14px;
	text-align: center;
	margin-top: 8px;
}

.btn:hover {
	background: #2980b9;
}

.btn-block {
	display: block;
	width: 100%;
}

.results {
	margin-top: 20px;
	padding: 12px;
	background: var(--light-color);
	border-radius: 4px;
	border-left: 3px solid var(--primary-color);
}

.results.error {
	border-left-color: var(--danger-color);
}

.results.success {
	border-left-color: var(--success-color);
}

.hidden {
	display: none;
}

.command-info {
	margin-top: 15px;
	padding: 10px;
	background: #e8f4fc;
	border-radius: 4px;
	font-size: 0.9em;
}

.command-examples {
	margin-top: 12px;
}

.command-examples pre {
	background: #2c3e50;
	color: white;
	padding: 8px;
	border-radius: 4px;
	overflow-x: auto;
	font-size: 0.85em;
}

================================================================================

<!-- File: generate-html\templates\param-field.ejs -->

<!-- File: templates/param-field.ejs -->

<div class="form-group">
    <label for="<%= param.name %>">
        <%= param.name %><%= param.required ? ' *' : '' %>
        <% if (param.description) { %>
            <span class="param-description"><%= param.description %></span>
        <% } %>
    </label>
    <%
    // Determine the input type based on parameter configuration
    if (param.enum) {
        // Enum parameter - render as select dropdown
    %>
        <select name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" <%= param.required ? 'required' : '' %> <% if (param.description) { %>title="<%- param.description %>"<% } %>>
            <% param.enum.forEach(function(option) { %>
                <option value="<%= option %>" <%= (defaultValue !== undefined && option == defaultValue) ? 'selected' : '' %>><%= option %></option>
            <% }); %>
        </select>
    <%
    } else if (param.type === 'boolean') {
        // Boolean parameter - render as checkbox
    %>
        <input type="checkbox" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" <%= (defaultValue !== undefined && defaultValue === true) ? 'checked' : '' %> <% if (param.description) { %>title="<%- param.description %>"<% } %>>
    <%
    } else if (param.type === 'integer' || param.type === 'number') {
        // Number parameter - render as number input
    %>
        <input type="number" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <% if (defaultValue !== undefined) { %>value="<%- defaultValue %>"<% } %> 
            <%= param.required ? 'required' : '' %> 
            <% if (param.min !== undefined) { %>min="<%- param.min %>"<% } %> 
            <% if (param.max !== undefined) { %>max="<%- param.max %>"<% } %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
    <%
    } else if (param.type === 'array') {
        // Array parameter - text input with comma-separated values
        let arrayValue = '';
        if (defaultValue !== undefined) {
            if (Array.isArray(defaultValue)) {
                arrayValue = defaultValue.join(', ');
            } else {
                arrayValue = String(defaultValue);
            }
        }
    %>
        <input type="text" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <% if (arrayValue) { %>value="<%- arrayValue %>"<% } %> 
            <%= param.required ? 'required' : '' %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
        <div class="array-format-help">Enter comma-separated values (e.g., value1, value2, value3)</div>
    <%
    } else if (param.description && param.description.length > 100) {
        // Long description - use textarea
    %>
        <textarea name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <%= param.required ? 'required' : '' %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
            <% if (defaultValue !== undefined) { %><%- defaultValue %><% } %>
        </textarea>
    <%
    } else {
        // Default - string input
    %>
        <input type="text" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <% if (defaultValue !== undefined) { %>value="<%- defaultValue %>"<% } %> 
            <%= param.required ? 'required' : '' %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
    <%
    }
    %>
</div>

================================================================================

<!-- File: generate-html\templates\spa-base.ejs -->

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title><%= htmlTitle || 'Command Interface' %></title>
		<link rel="stylesheet" href="app.css">
	</head>
	<body>
		<div class="container">
			<header>
				<h1><%= pageHeader || 'Command Interface' %></h1>
				<p>Execute commands through a web interface</p>
			</header>

			<div class="main-content">
				<div class="sidebar">
					<div>
						<label for="commandSelector"><%= commandSelectorLabel || 'Select Command:' %></label>
						<select id="commandSelector" class="command-selector">
							<option value="">Select a command...</option>
							<% commands.forEach(function(cmd) { %>
								<option value="<%= cmd.name %>"><%= cmd.name %></option>
							<% }); %>
						</select>
					</div>
				</div>

				<div class="content">
					<!-- Command forms will be inserted here -->
					<div id="formsContainer">
						<%- commandForms %>
					</div>

					<div id="resultsContainer" class="results hidden">
						<h3>Command Results</h3>
						<div id="resultsContent"></div>
					</div>
				</div>
			</div>
		</div>

		<script src="app.js"></script>
	</body>
</html>

================================================================================

<!-- File: http\config.json -->

{
	"port": 8080,
	"apiEndpoint": "/api",
	"paths": {
		"servedUIDir": "generated-ui"
	}
}

================================================================================

// File: http\HTTP.js

import { URL } from 'url';
import http from 'http';
import fs from 'fs';
import path from 'path';

export class HTTPServer {
	constructor(config = {}) {
		this.port = config.port || 8080;
		this.staticDir = config.paths?.servedUIDir || null;
		this.apiEndpoint = config.apiEndpoint || '/api';
		this.commandProcessor = null; // Will be initialized in start method
	}

	start(config = {}, commandProcessor) {
		// Validate config object
		if (typeof config !== 'object' || config === null) {
			throw new Error('config parameter must be an object');
		}

		if (
			!commandProcessor ||
			typeof commandProcessor.processCommand !== 'function'
		) {
			throw new Error(
				'start method requires a valid commandProcessor with processCommand method',
			);
		}

		// Extract paths from config object
		const paths = config.paths || {};

		// Initialize command processor with unified config
		this.commandProcessor = commandProcessor;

		// Use provided config with fallback defaults - only unnested format now
		const effectiveConfig = { ...config };

		// Use unnested port format only (no longer supports nested config.http.port)
		const effectivePort = this.port || config.port || 8080;
		const effectiveStaticDir = this.staticDir || config.paths?.servedUIDir || null;

		return new Promise((resolve, reject) => {
			const server = http.createServer(async (req, res) => {
				// Add CORS headers
				res.setHeader('Access-Control-Allow-Origin', '*');
				res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
				res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

				if (req.method === 'OPTIONS') {
					res.writeHead(200);
					res.end();
					return;
				}

				// Route to API endpoint if matches
				if (req.url.startsWith(this.apiEndpoint)) {
					await this.handleAPIRequest(req, res);
					return;
				}

				// Serve static files if directory is configured
				if (effectiveStaticDir) {
					await this.handleStaticRequest(req, res);
					return;
				}

				// Default to 404 if no static dir configured and not API
				res.writeHead(404, { 'Content-Type': 'application/json' });
				res.end(JSON.stringify({ error: 'Not found' }));
			});

			server.listen(effectivePort, () => {
				console.log(`üîó HTTP server running on port ${effectivePort}`);
				if (effectiveStaticDir) {
					console.log(`   Serving static files from: ${effectiveStaticDir}`);
				}
				console.log(
					`   API available at: http://localhost:${effectivePort}${this.apiEndpoint}`,
				);
				if (effectiveStaticDir) {
					console.log(`   UI available at: http://localhost:${effectivePort}/`);
				}
				resolve(server);
			});

			server.on('error', (err) => {
				console.error('Server error:', err.message);
				reject(err);
			});
		});
	}

	async handleAPIRequest(req, res) {
		try {
			const parsedUrl = new URL(req.url, `http://${req.headers.host}`);
			let commandString;

			if (req.method === 'GET') {
				commandString = parsedUrl.searchParams.get('command');
				if (!commandString) {
					// Fallback to 'json' parameter to maintain backward compatibility
					commandString = parsedUrl.searchParams.get('json');
				}
				if (commandString) {
					return await this.executeCommandAndRespond(commandString, res);
				}
				// If no command parameter, return 400
				return this.sendErrorResponse(res, "Missing 'command' parameter", 400);
			}

			if (req.method === 'POST') {
				let body = '';
				req.on('data', (chunk) => (body += chunk));
				req.on('end', async () => {
					try {
						const contentType = req.headers['content-type'] || '';

						if (contentType.includes('application/x-www-form-urlencoded')) {
							const params = new URLSearchParams(body);
							commandString = params.get('command') || params.get('json'); // backward compatibility
						} else if (contentType.includes('application/json')) {
							const json = JSON.parse(body);
							commandString = json?.command || json?.json; // backward compatibility
						}

						if (commandString) {
							await this.executeCommandAndRespond(commandString, res);
						} else {
							this.sendErrorResponse(
								res,
								"Missing 'command' in request body",
								400,
							);
						}
					} catch (err) {
						this.sendErrorResponse(
							res,
							`Invalid POST body: ${err.message}`,
							400,
						);
					}
				});
				return;
			}

			this.sendErrorResponse(res, 'Method not allowed', 405);
		} catch (err) {
			console.error('API handler error:', err);
			this.sendErrorResponse(res, `Internal server error: ${err.message}`, 500);
		}
	}

	async executeCommandAndRespond(commandString, res) {
		try {
			// Process command using the shared processor
			const result = await this.commandProcessor.processCommand(commandString);
			return this.sendResponse(res, result);
		} catch (err) {
			console.error('Command execution error:', err);
			return this.sendErrorResponse(res, err.message, 500);
		}
	}

	/**
	 * Send a response with appropriate status code
	 * @param {Object} res - HTTP response object
	 * @param {Object} result - Command result object
	 * @param {number} defaultStatusCode - Default status code if not in result
	 */
	sendResponse(res, result) {
		if (result.error) {
			return this.sendErrorResponse(res, result.error, 400);
		}

		res.writeHead(200, { 'Content-Type': 'application/json' });
		res.end(JSON.stringify(result));
	}

	/**
	 * Send an error response
	 * @param {Object} res - HTTP response object
	 * @param {string} errorMessage - Error message
	 * @param {number} statusCode - HTTP status code
	 */
	sendErrorResponse(res, errorMessage, statusCode = 400) {
		res.writeHead(statusCode, { 'Content-Type': 'application/json' });
		res.end(JSON.stringify({ error: errorMessage }));
	}

	async handleStaticRequest(req, res) {
		// Check if static directory is configured
		if (!this.staticDir) {
			return this.sendErrorResponse(
				res,
				'Static file serving not configured',
				404,
			);
		}

		// Check if the static directory exists and has index.html
		const indexPath = path.join(this.staticDir, 'index.html');
		if (!fs.existsSync(this.staticDir) || !fs.existsSync(indexPath)) {
			return this.sendErrorResponse(
				res,
				`Directory '${this.staticDir}' does not exist or is missing index.html. Please generate UI files first using 'node kernel.js --generate'`,
				404,
			);
		}

		// Remove query parameters and normalize path
		const url = new URL(req.url, `http://${req.headers.host}`);
		let filePath = url.pathname;

		// Default to index.html for root path
		if (filePath === '/' || filePath === '') {
			filePath = '/index.html';
		}

		// Resolve to absolute path and prevent directory traversal
		const safePath = path.normalize(filePath).replace(/^(\.\.[\/\\])+/, '');
		const fullPath = path.join(this.staticDir, safePath);

		// Check if the requested path is within the static directory
		if (!fullPath.startsWith(this.staticDir)) {
			res.writeHead(403, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: 'Forbidden' }));
			return;
		}

		// Check if file exists
		if (!fs.existsSync(fullPath)) {
			// Try index.html for SPA routing
			const indexPath = path.join(this.staticDir, 'index.html');
			if (fs.existsSync(indexPath)) {
				this.serveFile(indexPath, res);
				return;
			}

			res.writeHead(404, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: 'File not found' }));
			return;
		}

		this.serveFile(fullPath, res);
	}

	serveFile(filePath, res) {
		const ext = path.extname(filePath).toLowerCase();
		const contentType = this.getContentType(ext);

		fs.readFile(filePath, (err, content) => {
			if (err) {
				res.writeHead(500);
				res.end('Server Error');
			} else {
				res.writeHead(200, { 'Content-Type': contentType });
				res.end(content);
			}
		});
	}

	getContentType(ext) {
		const types = {
			'.html': 'text/html',
			'.css': 'text/css',
			'.js': 'application/javascript',
			'.json': 'application/json',
			'.png': 'image/png',
			'.jpg': 'image/jpeg',
			'.jpeg': 'image/jpeg',
			'.gif': 'image/gif',
			'.svg': 'image/svg+xml',
			'.ico': 'image/x-icon',
		};
		return types[ext] || 'application/octet-stream';
	}

	async respond(jsonString, res) {
		if (typeof jsonString === 'undefined') {
			res.writeHead(400, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: "Missing 'json' parameter" }));
			return;
		}

		try {
			const result = await this.apiHandler.handleInput(jsonString);

			if (result.error) {
				res.writeHead(400, { 'Content-Type': 'application/json' });
				res.end(JSON.stringify({ error: result.error }));
				return;
			}

			res.writeHead(200, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify(result));
		} catch (err) {
			res.writeHead(500, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: err.message }));
		}
	}
}


================================================================================

// File: http\index.js

import { HTTPServer } from './HTTP.js';

/**
 * HTTP plugin wrapper
 * Encapsulates the HTTP plugin instantiation and exposes functional interface
 */

// Plugin instance (singleton)
let httpInstance = null;

/**
 * Initialize and get the HTTP instance
 * @param {Object} config - Configuration object
 * @returns {HTTPServer} HTTP plugin instance
 */
function getHttpInstance(config) {
	if (!httpInstance) {
		httpInstance = new HTTPServer(config);
	}
	return httpInstance;
}

/**
 * Start the HTTP server plugin
 * @param {Object} config - Configuration object
 * @param {Object} commandProcessor - Command processor instance
 * @returns {Promise<void>}
 */
export async function start(config, commandProcessor) {
	const httpServer = getHttpInstance(config);
	return await httpServer.start(config, commandProcessor);
}

/**
 * Expose the plugin's start method for direct usage
 */
export default {
	start,
};


================================================================================

<!-- File: repl\config.json -->

{
	"maxHistory": 100,
	"paths": {
		"contextFilePath": "context/state.json",
		"replHistoryFilePath": "context/repl-history.json"
	}
}

================================================================================

// File: repl\index.js

import { REPL } from './REPL.js';

/**
 * REPL plugin wrapper
 * Encapsulates the REPL plugin instantiation and exposes functional interface
 */

// Plugin instance (singleton)
let replInstance = null;

/**
 * Initialize and get the REPL instance
 * @returns {REPL} REPL plugin instance
 */
function getReplInstance() {
	if (!replInstance) {
		replInstance = new REPL();
	}
	return replInstance;
}

/**
 * Start the REPL plugin
 * @param {Object} config - Configuration object
 * @param {Object} commandProcessor - Command processor instance
 * @returns {Promise<void>}
 */
export async function start(config, commandProcessor) {
	const repl = getReplInstance();
	return await repl.start(config, commandProcessor);
}

/**
 * Expose the plugin's start method for direct usage
 */
export default {
	start,
};


================================================================================

// File: repl\REPL.js

import readline from 'readline';
import fs from 'fs';
import path from 'path';
import { formatResult } from '../shared/format.js';

export class REPL {
	constructor() {
		// These will be initialized in the start method
		this.processor = null;
		this.maxHistory = 100;
		this.history = [];
		this.historyFilePath = null;
	}

	async initialize(config = {}) {
		// Validate config object
		if (typeof config !== 'object' || config === null) {
			throw new Error('config parameter must be an object');
		}

		// Extract paths from nested config object
		const paths = config.paths || {};

		// Use provided paths for file paths (configPath will be ignored since we now get config directly)
		const historyFilePath =
			paths.replHistoryFilePath ||
			paths.contextFilePath ||
			'context/repl-history.json';

		// Use unnested maxHistory format only (no longer supports nested config.repl.maxHistory)
		this.maxHistory = config.maxHistory || 100;
		this.historyFilePath = historyFilePath;
		this.loadHistory();
	}

	async start(config = {}, commandProcessor) {
		// Validate config object
		if (typeof config !== 'object' || config === null) {
			throw new Error('config parameter must be an object');
		}

		// Extract paths from nested config object
		const paths = config.paths || {};

		// Check if required paths are provided
		if (!paths.contextFilePath) {
			throw new Error(
				'config.paths must include contextFilePath for state management',
			);
		}

		if (
			!commandProcessor ||
			typeof commandProcessor.processCommand !== 'function'
		) {
			throw new Error(
				'start method requires a valid commandProcessor with processCommand method',
			);
		}

		// Initialize command processor
		this.processor = commandProcessor;
		this.contextFilePath = paths.contextFilePath;
		if (this.contextFilePath) this.processor.stateManager.loadState(this.contextFilePath);

		// Initialize with provided path and config values at the beginning of start
		await this.initialize(config);

		// Initialize REPL instance
		this.rl = readline.createInterface({
			input: process.stdin,
			output: process.stdout,
			prompt: this.processor.getManifest().prompt || '> ', // Use prompt from manifest or default fallback
			completer: (line) => this.commandCompleter(line),
		});

		// Load saved history into readline's history array for up/down navigation
		this.rl.history = [...this.history].reverse(); // Reverse to match readline's order (newest first)

		// Display welcome message and prompt
		console.log(
			`üîó ${this.processor.getManifest().name} - ${this.processor.getManifest().description}`,
		);
		console.log(
			'='.repeat(Math.max(this.processor.getManifest().name.length + 2, 40)),
		);
		console.log(
			'Type \"help()\" for available commands or \"exit()\" to quit.',
		);
		console.log('');

		this.rl.prompt();

		// Handle line input
		this.rl.on('line', async (input) => {
			input = input.trim();

			// Handle empty input
			if (!input) {
				this.rl.prompt();
				return;
			}

			// Add command to history
			this.addToHistory(input);

			// Process command using the shared processor
			const result = await this.processor.processCommand(
				input,
				this.contextFilePath,
			);

			if (result.error) console.error(`‚ùå ${result.error}`);
			if (result.output) console.log(formatResult(result.output));

			// Check if the command requested exit
			if (result.exit) {
				this.rl.close();
				return;
			}

			this.rl.prompt();
		});

		this.rl.on('close', () => {
			process.exit(0);
		});

		process.on('SIGINT', () => {
			console.log('\\nUse \\\\\"exit\\\\" or Ctrl+D to quit.');
			this.rl.prompt();
		});
	}

	/* ---------- unchanged helpers ---------- */
	commandCompleter(line) {
		// Include built-in commands in completion
		const commands = [
			...this.processor.getManifest().commands.map((c) => c.name),
			'help',
			'exit',
		];
		const hits = commands.filter((c) => c.startsWith(line));
		return [hits.length ? hits : commands, line];
	}

	addToHistory(input) {
		if (input.trim()) {
			// Add to history if it's not a duplicate of the last entry
			if (
				this.history.length === 0 ||
				this.history[this.history.length - 1] !== input.trim()
			) {
				this.history.push(input.trim());
				// Keep only the most recent maxHistory entries
				if (this.history.length > this.maxHistory) {
					this.history = this.history.slice(-this.maxHistory);
				}
				this.saveHistory();
			}
		}
	}

	loadHistory() {
		try {
			if (fs.existsSync(this.historyFilePath)) {
				const historyData = fs.readFileSync(this.historyFilePath, 'utf8');
				const savedHistory = JSON.parse(historyData);
				if (Array.isArray(savedHistory)) {
					// Limit to maxHistory items
					this.history = savedHistory.slice(-this.maxHistory);
				}
			}
		} catch (error) {
			console.warn(
				'‚ö†Ô∏è Could not load REPL history, starting fresh:',
				error.message,
			);
			this.history = [];
		}
	}

	saveHistory() {
		try {
			// Ensure context directory exists
			const contextDir = path.dirname(this.historyFilePath);
			if (!fs.existsSync(contextDir)) {
				fs.mkdirSync(contextDir, { recursive: true });
			}

			fs.writeFileSync(
				this.historyFilePath,
				JSON.stringify(this.history, null, 2),
			);
		} catch (error) {
			console.warn('‚ö†Ô∏è Could not save REPL history:', error.message);
		}
	}
}


================================================================================

// File: shared\format.js

// File: processor\format.js

/**
 * Format command output results into human-readable strings
 * Used by transports that want basic text formatting (CLI, REPL, etc.)
 * Transports can opt-out by setting formatToString=false and handle their own formatting
 */

/**
 * Format a command output result into a human-readable string
 * @param {*} output - The output to format (any type)
 * @returns {string} - Formatted string representation
 */
export function formatResult(output) {
	// Handle primitive types and null/undefined
	if (output === null) {
		return 'null';
	}

	if (output === undefined) {
		return 'undefined';
	}

	if (typeof output === 'string') {
		return output;
	}

	if (typeof output === 'number' || typeof output === 'boolean') {
		return String(output);
	}

	// Handle arrays and objects with clean, human-friendly formatting
	if (typeof output === 'object') {
		return formatObject(output);
	}

	// Catch-all for any other types
	return String(output);
}

/**
 * Format objects and arrays with clean, human-readable indentation
 * @param {Object|Array} obj - The object or array to format
 * @param {number} indentLevel - Current indentation level (internal use)
 * @returns {string} - Formatted string
 */
function formatObject(obj, indentLevel = 0) {
	const indent = '  '.repeat(indentLevel);

	if (Array.isArray(obj)) {
		return formatArray(obj, indentLevel);
	}

	// Handle plain objects
	const entries = Object.entries(obj);

	if (entries.length === 0) {
		return '';
	}

	const formattedEntries = entries.map(([key, value]) => {
		return `${indent}${key}: ${formatValue(value, indentLevel + 1)}`;
	});

	return formattedEntries.join('\n');
}

/**
 * Format arrays with clean, human-readable indentation
 * @param {Array} array - The array to format
 * @param {number} indentLevel - Current indentation level
 * @returns {string} - Formatted string
 */
function formatArray(array, indentLevel = 0) {
	const indent = '  '.repeat(indentLevel);

	if (array.length === 0) {
		return '';
	}

	const formattedItems = array.map((item) => {
		return `${indent}  ${formatValue(item, indentLevel + 1)}`;
	});

	return formattedItems.join('\n');
}

/**
 * Format a single value with appropriate indentation
 * @param {*} value - The value to format
 * @param {number} indentLevel - Current indentation level
 * @returns {string} - Formatted value
 */
function formatValue(value, indentLevel) {
	if (value === null) return 'null';
	if (value === undefined) return 'undefined';

	if (typeof value === 'string') {
		return value;
	}

	if (typeof value === 'number' || typeof value === 'boolean') {
		return String(value);
	}

	if (typeof value === 'object') {
		// For nested objects/arrays, format with proper indentation
		if (Array.isArray(value)) {
			return `\n${formatArray(value, indentLevel)}`;
		}
		return `\n${formatObject(value, indentLevel)}`;
	}

	return String(value);
}


================================================================================

