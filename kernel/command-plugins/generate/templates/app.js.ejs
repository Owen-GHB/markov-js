// File: templates/app.js.ejs

// Client-side JavaScript for EJS-generated UI
(function() {
    'use strict';

    // Initialize state from global defaults
    let state = <%- JSON.stringify(initialState, null, 2) %>;
    
    // Available commands
    const commands = <%- JSON.stringify(commands, null, 2) %>;
    
    // Map of command manifests by name for quick lookup
    const commandManifests = {};
    commands.forEach(cmd => {
        commandManifests[cmd.name] = cmd;
    });
    
    // DOM elements
    const commandSelector = document.getElementById('commandSelector');
    const formsContainer = document.getElementById('formsContainer');
    const resultsContainer = document.getElementById('resultsContainer');
    const resultsContent = document.getElementById('resultsContent');
    
    // Show a specific form and hide others
    function showForm(commandName) {
        // Hide all forms
        document.querySelectorAll('.form-container').forEach(form => {
            form.classList.remove('active-form');
        });
        
        // Show the selected form if it exists
        if (commandName) {
            const form = document.getElementById(commandName + '-form');
            if (form) {
                form.classList.add('active-form');
            }
        }
    }
    
    // Handle command selection change
    commandSelector.addEventListener('change', function(e) {
        const commandName = e.target.value;
        showForm(commandName);
        
        // Scroll to the form
        if (commandName) {
            const form = document.getElementById(commandName + '-form');
            if (form) {
                form.scrollIntoView({ behavior: 'smooth' });
            }
        }
    });
    
    // Handle form submissions - SINGLE HANDLER
    document.addEventListener('submit', function(e) {
        if (e.target.classList.contains('command-form')) {
            e.preventDefault();
            handleCommandSubmit(e.target);
        }
    });
    
    // Process a command form submission - UPDATED FOR FILE SUPPORT
    async function handleCommandSubmit(form) {
        const commandName = form.getAttribute('data-command');
        if (!commandName) return;
        
        const cmdManifest = commandManifests[commandName];
        if (!cmdManifest) {
            showResults({ error: 'Command not found: ' + commandName }, 'error');
            return;
        }
        
        // Check if this form has file inputs with files
        const fileInputs = form.querySelectorAll('input[type="file"]');
        let hasFiles = false;
        const files = new FormData();
        
        for (const input of fileInputs) {
            if (input.files.length > 0) {
                files.append(input.name, input.files[0]);
                hasFiles = true;
            }
        }
        
        if (hasFiles) {
            // Handle file upload via multipart form
            await executeCommandWithFiles(commandName, form, files);
        } else {
            // Handle regular form submission
            await executeCommandRegular(commandName, form);
        }
    }
    
    // Execute command with file uploads
    async function executeCommandWithFiles(commandName, form, files) {
        const cmdManifest = commandManifests[commandName];
        const args = {};
        const paramManifests = cmdManifest.parameters || {};
        
        // Extract arguments from form fields
        const inputs = form.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            if (input.type === 'file') return; // Skip file inputs (handled separately)
            
            const paramName = input.getAttribute('data-param-name') || input.name;
            if (!paramName) return;
            
            const param = paramManifests[paramName];
            if (!param) return;
            
            // Skip blob parameters (they're handled via file upload)
            if (param.type && param.type.includes('blob')) return;
            
            let value;
            
            // Extract value based on input type
            if (input.type === 'checkbox') {
                value = input.checked;
            } else if (input.type === 'number') {
                value = input.value ? Number(input.value) : (param.required ? 0 : undefined);
            } else if (input.type === 'select-multiple') {
                // Handle multi-select
                const selectedOptions = Array.from(input.selectedOptions);
                value = selectedOptions.map(option => option.value);
            } else {
                value = input.value !== undefined ? input.value : (input.textContent || input.innerText);
                
                // Handle JSON objects/arrays (optional fallback)
                if (param.type === 'array' && value) {
                    value = value.split(',').map(v => v.trim()).filter(v => v);
                }
            }
            
            // Apply runtime fallback
            if ((value === undefined || value === '' || value === null) && param.runtimeFallback && state[param.runtimeFallback] !== undefined) {
                value = state[param.runtimeFallback];
            }
            
            if (value !== undefined && value !== '' && value !== null) {
                args[paramName] = value;
            }
        });
        
        // Add the command JSON to the form data
        files.append('command', JSON.stringify({
            name: commandName,
            args: args
        }));
        
        try {
            if (window.electronAPI) {
                // Convert FormData to a format Electron can handle
                const commandData = {
                    name: commandName,
                    args: args
                };
                
                // Handle file data for Electron
                const fileEntries = [];
                for (const [key, file] of files.entries()) {
                    if (key !== 'command') {
                        const arrayBuffer = await file.arrayBuffer();
                        fileEntries.push({
                            paramName: key,
                            fileName: file.name,
                            fileType: file.type,
                            fileSize: file.size,
                            data: Array.from(new Uint8Array(arrayBuffer))
                        });
                    }
                }
                
                if (fileEntries.length > 0) {
                    commandData.files = fileEntries;
                }
                
                const result = await window.electronAPI.executeCommand(commandData);
                
                // Update state based on side effects
                state = updateState(state, { name: commandName, args: args }, result, cmdManifest);
                
                // Show results
                showResults(result, result.error ? 'error' : 'success');
            } else {
                // HTTP fallback (existing behavior)
                const response = await fetch('/api', {
                    method: 'POST',
                    body: files
                });
                
                const result = await response.json();
                
                // Update state based on side effects
                state = updateState(state, { name: commandName, args: args }, result, cmdManifest);
                
                // Show results
                showResults(result, result.error ? 'error' : 'success');
            }
        } catch (error) {
            showResults({ error: 'Network Error: ' + error.message }, 'error');
        }
    }
    
    // Execute regular command (no files)
    async function executeCommandRegular(commandName, form) {
        const cmdManifest = commandManifests[commandName];
        const args = {};
        const paramManifests = cmdManifest.parameters || {};
        
        // Extract arguments from form fields
        const inputs = form.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            if (input.type === 'file') return; // Skip file inputs
            
            const paramName = input.getAttribute('data-param-name') || input.name;
            if (!paramName) return;
            
            const param = paramManifests[paramName];
            if (!param) return;
            
            let value;
            
            // Extract value based on input type
            if (input.type === 'checkbox') {
                value = input.checked;
            } else if (input.type === 'number') {
                value = input.value ? Number(input.value) : (param.required ? 0 : undefined);
            } else if (input.type === 'select-multiple') {
                // Handle multi-select
                const selectedOptions = Array.from(input.selectedOptions);
                value = selectedOptions.map(option => option.value);
            } else {
                value = input.value !== undefined ? input.value : (input.textContent || input.innerText);
                
                // Handle JSON objects/arrays (optional fallback)
                if (param.type === 'array' && value) {
                    value = value.split(',').map(v => v.trim()).filter(v => v);
                }
            }
            
            // Apply runtime fallback only if the field value is empty/undefined and a fallback exists
            if ((value === undefined || value === '' || value === null) && param.runtimeFallback && state[param.runtimeFallback] !== undefined) {
                value = state[param.runtimeFallback];
            }
            
            // For checkboxes, we should always include the value (true/false), otherwise only add to args if value exists and is not empty
            if (input.type === 'checkbox') {
                args[paramName] = value || false;
            } else if (value !== undefined && value !== '' && value !== null) {
                args[paramName] = value;
            }
        });
        
        // Prepare command object
        const command = {
            name: commandName,
            args: args
        };
        
        console.log('Executing command:', command);
        
        try {
            if (window.electronAPI) {
                const result = await window.electronAPI.executeCommand(command);
                
                // Update state based on side effects
                state = updateState(state, command, result, cmdManifest);
                
                // Show results
                showResults(result, result.error ? 'error' : 'success');
            } else {
                // HTTP fallback (existing behavior)
                const response = await fetch('/api?command=' + encodeURIComponent(JSON.stringify(command)));
                const result = await response.json();
                
                // Update state based on side effects
                state = updateState(state, command, result, cmdManifest);
                
                // Show results
                showResults(result, result.error ? 'error' : 'success');
            }
        } catch (error) {
            showResults({ error: 'Network Error: ' + error.message }, 'error');
        }
    }
    
    // Extract value from form field
    function extractFieldValue(field, param) {
        if (!field) return undefined;
        
        if (field.type === 'checkbox') {
            return field.checked;
        } else if (field.type === 'number') {
            return field.value ? Number(field.value) : undefined;
        } else if (field.type === 'select-multiple') {
            // Handle multi-select
            const selectedOptions = Array.from(field.selectedOptions);
            return selectedOptions.map(option => option.value);
        } else {
            let value = field.value !== undefined ? field.value : (field.textContent || field.innerText);
            
            // comma-separated values for arrays
            if (param.type === 'array' && value && typeof value === 'string') {
                value = value.split(',').map(v => v.trim()).filter(v => v);
            }
            
            // Handle JSON objects/arrays (optional fallback)
            if ((param.type === 'object' || param.type === 'array') && value && typeof value === 'string') {
                // Only try JSON parsing if it looks like JSON
                if ((value.startsWith('{') && value.endsWith('}')) || 
                    (value.startsWith('[') && value.endsWith(']'))) {
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        console.warn('Failed to parse JSON for parameter:', param.name, value);
                        // Keep original value if JSON parsing fails
                    }
                }
            }
            
            return value;
        }
    }
    
    // Validate a command (simplified - would use actual validation in real implementation)
    function validateCommand(command, cmdManifest) {
        return {
            isValid: true,
            errors: []
        };
    }
    
    // Update state based on command side effects (simplified)
    function updateState(state, command, result, cmdManifest) {
        // This is a simplified version - in a real implementation, 
        // you would use proper state management
        return Object.assign({}, state);
    }
    
    // File upload handling - setup file input events
    function setupFileInputs() {
        const fileInputs = document.querySelectorAll('input[type="file"]');
        
        fileInputs.forEach(input => {
            const infoDiv = document.getElementById(`${input.id}-info`);
            if (!infoDiv) return;
            
            input.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    // Validate file size
                    const maxSize = input.getAttribute('data-max-size');
                    if (maxSize && file.size > parseInt(maxSize)) {
                        alert(`File too large. Maximum size: ${(maxSize / 1024 / 1024).toFixed(1)} MB`);
                        input.value = '';
                        infoDiv.style.display = 'none';
                        return;
                    }
                    
                    // Validate file type
                    const allowedTypes = input.getAttribute('data-allowed-types');
                    if (allowedTypes && !allowedTypes.split(',').includes(file.type)) {
                        alert(`File type not allowed. Allowed types: ${allowedTypes}`);
                        input.value = '';
                        infoDiv.style.display = 'none';
                        return;
                    }
                    
                    // Validate file extension
                    const allowedExtensions = input.getAttribute('accept');
                    if (allowedExtensions) {
                        const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
                        const acceptedExtensions = allowedExtensions.split(',').map(ext => ext.trim());
                        if (!acceptedExtensions.includes(fileExtension)) {
                            alert(`File extension not allowed. Allowed: ${acceptedExtensions.join(', ')}`);
                            input.value = '';
                            infoDiv.style.display = 'none';
                            return;
                        }
                    }
                    
                    // Show file info
                    infoDiv.querySelector('.file-name').textContent = file.name;
                    infoDiv.querySelector('.file-size').textContent = formatFileSize(file.size);
                    infoDiv.style.display = 'block';
                } else {
                    infoDiv.style.display = 'none';
                }
            });
        });
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Show results in the results container
    function showResults(result, type = 'success') {
        resultsContainer.classList.remove('hidden', 'error', 'success');
        
        // Determine the appropriate type and content to display
        if (result.error) {
            resultsContainer.classList.add('error');
            resultsContent.innerHTML = '<strong>Error:</strong><br><code>' + escapeHtml(result.error) + '</code>';
        } else if (result.output) {
            resultsContainer.classList.add('success');
            // Format output, handling newlines properly
            let formattedOutput = escapeHtml(String(result.output)).replace(/\n/g, '<br>');
            resultsContent.innerHTML = '<strong>Output:</strong><br><code>' + formattedOutput + '</code>';
        } else {
            // If no specific error or output, show the full result for debugging
            resultsContainer.classList.add(type);
            resultsContent.innerHTML = '<pre>' + escapeHtml(JSON.stringify(result, null, 2)) + '</pre>';
        }
    }
    
    // Escape HTML special characters to prevent XSS
    function escapeHtml(str) {
        if (typeof str !== 'string') return String(str);
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    
    // Initialize - hide all forms initially and setup file inputs
    function initialize() {
        showForm('');
        setupFileInputs();
        console.log('EJS-generated UI initialized with', commands.length, 'commands');
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();