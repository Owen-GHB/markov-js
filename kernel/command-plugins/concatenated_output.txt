<!-- File: commands.json -->

{
  "set": {
    "commandType": "internal",
    "description": "Set kernel state values at runtime",
    "parameters": {
      "configstate": {
        "type": "string",
        "required": true,
        "description": "State key to set (supports dot notation for nested objects)"
      },
      "value": {
        "type": "string|integer|number|boolean|array|object",
        "required": true,
        "description": "Value to set (auto-converted from string if needed)"
      },
      "persist": {
        "type": "boolean", 
        "required": false,
        "default": true,
        "description": "Whether to persist the change to context file"
      }
    }
  }
}

================================================================================

<!-- File: contract.json -->

{
  "name": "vertex-kernel",
  "version": "0.0.0", 
  "description": "Universal Command Engine - Plugin Ecosystem",
  "sources": {
    "generate": "./generate",
    "http": "./http",
    "electron": "./electron"
  },
  "stateDefaults": {
    "pluginsDir": "./kernel-plugins",
    "contextFilePath": "./context/state.json",
    "replHistoryFilePath": "./context/repl-history.txt",
    "maxReplHistory": 100
  }
}

================================================================================

<!-- File: help.json -->

{
  "set": {
    "examples": [
      "set(\"serverPort\", 3000)",
      "set(configstate=\"servedUIDir\", value=\"./dist\")",
      "set({configstate: \"electron.showDevTools\", value: false})",
      "set(\"userTemplateDir\", \"./custom-templates\", persist=false)"
    ],
    "notes": "Dynamically modifies kernel state. Supports nested keys with dot notation. Changes are persisted by default. Use persist=false for temporary changes."
  }
}

================================================================================

<!-- File: runtime.json -->

{
  "set": {
    "sideEffects": {
      "setState": {
        "{{configstate}}": {"fromParam": "value"}
      }
    },
    "successOutput": "✅ Set {{configstate}} = {{value}}{{#persist}} (persisted){{/persist}}{{^persist}} (temporary){{/persist}}"
  }
}

================================================================================

<!-- File: electron\commands.json -->

{
  "electron": {
    "commandType": "kernel-plugin",
    "methodName": "start",
    "description": "Launch Electron desktop application",
    "parameters": {
      "servedui": {
        "type": "string",
        "required": false,
        "runtimeFallback": "servedUIDir", 
        "description": "UI directory to load in Electron window"
      },
      "electronPreloadPath": {
        "type": "string",
        "required": false,
        "runtimeFallback": "electronPreloadPath",
        "description": "Path to Electron preload script"
      }
    }
  }
}

================================================================================

<!-- File: electron\contract.json -->

{
  "name": "electron-plugin",
  "version": "0.0.0", 
  "description": "Electron Desktop Application",
  "stateDefaults": {
    "servedUIDir": "./generated-ui",
    "electronPreloadPath": "./electron-preload.js",
    "windowWidth": 1200,
    "windowHeight": 800,
    "showDevTools": true,
    "isElectronRunning": false
  }
}

================================================================================

// File: electron\electron-main.js

// File: electron/electron-main.js

import { ElectronApp } from './ElectronApp.js';
import path from 'path';
import { pathToFileURL } from 'url';

// Parse command line arguments to get project root, kernel path, and electron parameters
const args = process.argv.slice(2);
const argMap = {};
for (let i = 0; i < args.length; i += 2) {
    if (args[i].startsWith('--')) {
        const key = args[i].substring(2);
        const value = args[i + 1];
        argMap[key] = value;
    }
}

const projectRoot = argMap['project-root'];
const kernelPath = argMap['kernel-path'];
const servedui = argMap['servedui'];
const electronPreloadPath = argMap['electron-preload-path'];

if (!projectRoot || !kernelPath) {
    console.error(
        '❌ Missing required arguments: --project-root and --kernel-path',
    );
    process.exit(1);
}

// Create and start the Electron application by dynamically loading kernel modules
(async () => {
    try {
        const manifestUrl = pathToFileURL(path.join(kernelPath, 'contract.js')).href;
		const { manifestReader } = await import(manifestUrl);
		const manifest = manifestReader(projectRoot);
		const commandProcessorUrl = pathToFileURL(path.join(kernelPath, 'processor/CommandProcessor.js')).href;
		const { CommandProcessor } = await import(commandProcessorUrl);
		const commandProcessor = new CommandProcessor(
			projectRoot,
			manifest
		);

        // Directly instantiate and start ElectronApp with the dynamically created components
        const electronApp = new ElectronApp();

        await electronApp.start(servedui, electronPreloadPath, commandProcessor);
    } catch (error) {
        console.error('❌ Error in Electron main process:', error.message);
        process.exit(1);
    }
})();

================================================================================

// File: electron\ElectronApp.js

import { app, BrowserWindow, ipcMain } from 'electron';
import fs from 'fs';
import path from 'path';

/**
 * Manages the UI for the Electron application, including checking and loading
 */
class ElectronUIManager {
	/**
	 * Check if the served UI directory exists and has required files
	 * @param {string} filename - The UI filename to check (default: 'index.html')
	 * @param {Object} paths - Paths object containing required paths
	 * @returns {boolean} True if the served UI directory exists and has the file
	 */
	hasServedUI(filename = 'index.html', servedUIDir) {
		const servedDir = servedUIDir;
		const indexPath = path.join(servedDir, filename);
		return fs.existsSync(servedDir) && fs.existsSync(indexPath);
	}

	/**
	 * Get the UI file path from the served UI directory
	 * @param {string} filename - The UI filename (default: 'index.html')
	 * @param {Object} paths - Paths object containing required paths
	 * @returns {string} The path to the UI file
	 */
	getUIPath(filename = 'index.html', servedUIDir) {
		const servedDir = servedUIDir;
		return path.join(servedDir, filename);
	}
}

/**
 * Handles commands for the Electron application via IPC
 */
class ElectronCommandHandler {
	constructor(commandProcessor) {
		this.commandProcessor = commandProcessor;
	}

	/**
	 * Execute a command through the kernel
	 * @param {Object} command - The command to execute
	 * @returns {Promise<Object>} - The result of the command execution
	 */
	async executeCommand(command) {
		try {
			// The command from UI is already parsed as an object
			// We'll pass it through the processor to handle state management properly
			// Convert command object to expected format for processCommand if needed
			const commandString = JSON.stringify(command);
			const result = await this.commandProcessor.processCommand(commandString);
			return result;
		} catch (error) {
			return { error: error.message, output: null };
		}
	}
}

export class ElectronApp {
	constructor(options = {}) {
		this.uiManager = new ElectronUIManager();
		this.commandHandler = null; // Will be initialized in start method
		this.options = options;
		this.windowOptions = {
			width: options.width || 1200,
			height: options.height || 800,
			webPreferences: {
				nodeIntegration: false,
				contextIsolation: true,
				preload: options.preloadPath || null, // Will be set in start method
			},
			...options.windowOptions,
		};
		this.showDevTools = options.showDevTools !== false; // Default to true unless explicitly disabled
	}

	createWindow() {
		const mainWindow = new BrowserWindow(this.windowOptions);

		// Check if UI exists first, refuse to work if not
		if (!this.uiManager.hasServedUI('index.html', this.paths.servedUIDir)) {
			console.error(
				"UI files not found. Please generate UI files first using 'node kernel.js --generate'",
			);
			// Show error and close the window
			mainWindow.loadURL(
				`data:text/html,<h1>UI Files Not Found</h1><p>Please generate UI files first using 'node kernel.js --generate'</p><p>The Electron app will close in 5 seconds.</p>`,
			);

			// Close the window after a delay to let the user see the error
			setTimeout(() => {
				mainWindow.close();
				if (BrowserWindow.getAllWindows().length === 0) {
					app.quit();
				}
			}, 5000);

			return mainWindow;
		}

		// Load the UI from the served UI directory
		try {
			const uiPath = this.uiManager.getUIPath('index.html', this.paths.servedUIDir);
			// Load the generated UI
			mainWindow.loadFile(uiPath);
		} catch (err) {
			console.error('Failed to load UI:', err);
			// Load an error page
			mainWindow.loadURL(
				`data:text/html,<h1>UI Loading Failed</h1><p>${err.message}</p>`,
			);
		}

		// Open the DevTools if specified
		if (this.showDevTools) {
			mainWindow.webContents.openDevTools();
		}

		return mainWindow;
	}

	setupIPC() {
		// IPC handler to execute commands via the kernel
		ipcMain.handle('execute-command', async (event, command) => {
			return await this.commandHandler.executeCommand(command);
		});
	}

	async start(servedUIDir, electronPreloadPath, commandProcessor) {
		// Validate parameters
		if (!servedUIDir) {
			console.error('❌ servedUIDir path must be provided');
			process.exit(1);
		}
		if (!electronPreloadPath) {
			console.error('❌ electronPreloadPath path must be provided');
			process.exit(1)
		}
		if (!commandProcessor) {
			console.error('❌ commandProcessor must be provided');
			process.exit(1);
		}

		// Store paths for use by UI manager methods
		this.paths = {servedUIDir, electronPreloadPath};

		// Initialize command handler
		this.commandHandler = new ElectronCommandHandler(commandProcessor);

		// Update the preload path in webPreferences
		this.windowOptions.webPreferences.preload = electronPreloadPath;

		// Ensure preload script exists
		if (
			this.windowOptions.webPreferences.preload &&
			!fs.existsSync(this.windowOptions.webPreferences.preload)
		) {
			console.error(
				`Preload script not found at: ${this.windowOptions.webPreferences.preload}`,
			);
			console.error('This may cause IPC to not work properly.');
		}

		this.setupIPC();

		// This method will be called when Electron has finished
		// initialization and is ready to create browser windows.
		app.whenReady().then(() => {
			this.createWindow();

			app.on('activate', () => {
				// On macOS it's common to re-create a window in the app when the
				// dock icon is clicked and there are no other windows open.
				if (BrowserWindow.getAllWindows().length === 0) {
					this.createWindow();
				}
			});
		});

		// Quit when all windows are closed, except on macOS. There, it's common
		// for applications and their menu bar to stay active until the user quits
		// explicitly with Cmd + Q.
		app.on('window-all-closed', () => {
			if (process.platform !== 'darwin') {
				app.quit();
			}
		});
	}
}


================================================================================

<!-- File: electron\help.json -->

{
  "electron": {
    "examples": [
      "electron()",
      "electron(servedui=\"./dist\")",
      "electron(servedui=\"./public\", electronPreloadPath=\"./preload.js\")"
    ],
    "notes": "Launches as separate process. Falls back gracefully if UI files missing. Requires Electron dependency."
  }
}

================================================================================

// File: electron\index.js

// File: electron/index.js

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Start the Electron plugin by launching electron-main.js via npx
 * @param {string} kernelPath - Path to the kernel directory
 * @param {string} projectRoot - Project root directory
 * @param {string} servedui - Directory for served UI files
 * @param {string} electronPreloadPath - Path to electron preload script
 * @returns {Promise<void>}
 */
export async function start(kernelPath, projectRoot, servedui, electronPreloadPath) {
    // Since Electron needs to be launched as a separate process, we spawn electron using npx
    // which will run electron-main.js. The electron-main.js will now use dynamic kernel loading.
    return import('child_process')
        .then(({ spawn }) => {
            if (!kernelPath) {
                throw new Error('kernelPath must be provided as a parameter');
            }

            // Launch electron with the electron-main.js file and pass the required paths as arguments
            const electronMainPath = path.join(__dirname, 'electron-main.js');
            
            const args = [
                'electron',
                electronMainPath,
                '--project-root',
                projectRoot,
                '--kernel-path',
                kernelPath,
            ];

            // Add optional parameters if provided
            if (servedui) {
                args.push('--servedui', servedui);
            }
            if (electronPreloadPath) {
                args.push('--electron-preload-path', electronPreloadPath);
            }

            const npxProcess = spawn('npx', args, {
                stdio: 'inherit',
                cwd: projectRoot, // Crucial: run from project root
                shell: true,
            });

            npxProcess.on('error', (err) => {
                console.error('❌ Failed to start Electron:', err.message);
                console.log(
                    'Make sure you have installed Electron as a dev dependency: npm install --save-dev electron',
                );
                process.exit(1);
            });

            npxProcess.on('close', (code) => {
                console.log(`Electron process exited with code ${code}`);
                process.exit(code);
            });
        })
        .catch((err) => {
            console.error('❌ Failed to launch Electron:', err.message);
            process.exit(1);
        });
}

export default {
    start,
};

================================================================================

<!-- File: electron\runtime.json -->

{
  "electron": {
    "sideEffects": {
      "setState": {
        "servedUIDir": {"fromParam": "servedui"},
        "electronPreloadPath": {"fromParam": "electronPreloadPath"},
        "isElectronRunning": true, 
        "currentMode": "electron",
        "lastOperation": {"template": "launched_electron_with_{{servedui}}"}
      }
    },
    "successOutput": "🖥️ Electron desktop app launched!\n   UI: {{servedui}}\n   Preload: {{electronPreloadPath}}"
  }
}

================================================================================

<!-- File: generate\commands.json -->

{
  "generate": {
    "commandType": "kernel-plugin",
    "methodName": "run",
    "description": "Generate web UI from contract using EJS templates",
    "parameters": {
      "userTemplateDir": {
        "type": "string",
        "required": false,
        "runtimeFallback": "userTemplateDir",
        "description": "Custom template directory (uses built-in if not provided)"
      },
      "generatedUIDir": {
        "type": "string", 
        "required": false,
        "runtimeFallback": "generatedUIDir",
        "description": "Output directory for generated UI files"
      }
    }
  }
}

================================================================================

<!-- File: generate\contract.json -->

{
  "name": "generate-plugin",
  "version": "0.0.0",
  "description": "EJS-based UI Generation System",
  "stateDefaults": {
    "userTemplateDir": "./ejs-templates",
    "generatedUIDir": "./generated-ui",
    "uiGenerationCount": 0,
    "lastTemplateUsed": "built-in"
  }
}

================================================================================

<!-- File: generate\help.json -->

{
  "generate": {
    "examples": [
      "generate()",
      "generate(generatedUIDir=\"./dist\")",
      "generate(userTemplateDir=\"./my-templates\", generatedUIDir=\"./public\")"
    ],
    "notes": "Generates complete SPA with forms for all commands. Overwrites existing files by default."
  }
}

================================================================================

// File: generate\index.js

// File: generate/index.js

import { UI } from './UI.js';
import path from 'path';
import { pathToFileURL } from 'url';

// Plugin instance (singleton)
let generatorInstance = null;

function getGeneratorInstance() {
    if (!generatorInstance) {
        generatorInstance = new UI();
    }
    return generatorInstance;
}

/**
 * Run the EJS-based generator plugin
 * @param {string} userTemplateDir - Directory for user templates
 * @param {string} generatedUIDir - Directory for generated UI output
 * @param {string} kernelPath - Path to kernel directory
 * @param {string} projectRoot - Project root directory (defaults to cwd)
 * @returns {Promise<void>}
 */
export async function run(kernelPath, projectRoot, userTemplateDir, generatedUIDir) {
    const manifestUrl = pathToFileURL(path.join(kernelPath, 'contract.js')).href;
	const { manifestReader } = await import(manifestUrl);
	const manifest = manifestReader(projectRoot);
    
    const generator = getGeneratorInstance();
    return await generator.run(userTemplateDir, generatedUIDir, manifest);
}

export default {
    run,
};

================================================================================

<!-- File: generate\runtime.json -->

{
  "generate": {
    "sideEffects": {
      "setState": {
        "userTemplateDir": {"fromParam": "userTemplateDir"},
        "generatedUIDir": {"fromParam": "generatedUIDir"},
        "uiGenerationCount": {"template": "{{uiGenerationCount}} + 1"},
        "lastTemplateUsed": {"template": "{{#userTemplateDir}}custom{{/userTemplateDir}}{{^userTemplateDir}}built-in{{/userTemplateDir}}"},
        "lastOperation": {"template": "generated_ui_to_{{generatedUIDir}}"}
      }
    },
    "successOutput": "🎨 UI generated successfully!\n   Output: {{generatedUIDir}}\n   Templates: {{#userTemplateDir}}{{userTemplateDir}}{{/userTemplateDir}}{{^userTemplateDir}}built-in{{/templateDir}}\n   Generation #{{uiGenerationCount}}"
  }
}

================================================================================

// File: generate\UI.js

// File: UI.js

import fs from 'fs';
import path from 'path';
import ejs from 'ejs';
import { fileURLToPath } from 'url';

/**
 * Main EJS-based UI Generator class that creates a complete SPA from contract manifests
 */
export class UI {
	constructor() {
		this.__dirname = path.dirname(fileURLToPath(import.meta.url));
	}

	    /**
     * Generate the complete SPA from manifests using EJS templates
     * @param {string} userTemplateDir - Directory for user templates  
     * @param {string} generatedUIDir - Directory for generated UI output
     * @param {Object} manifest - The contract manifest with global and command information
     */
	async run(userTemplateDir, generatedUIDir, manifest) {
		try {
			const outputDir = generatedUIDir;

			// First try user templates, fall back to built-in templates
			let templateDir;
			if (userTemplateDir && fs.existsSync(userTemplateDir)) {
				templateDir = userTemplateDir;
				console.log(`Using user templates from: ${templateDir}`);
			} else {
				// Fall back to built-in templates
				templateDir = path.resolve(this.__dirname, 'templates');
				console.log(`Using built-in templates from: ${templateDir}`);

				// Verify built-in templates exist
				if (!fs.existsSync(templateDir)) {
					throw new Error(
						`Built-in templates directory not found: ${templateDir}. Please ensure the templates are included with the generator.`,
					);
				}
			}

			console.log('Starting EJS-based UI generation...');

			// Use the provided manifest directly
			const globalManifest = manifest;
			const commandManifests = manifest.commands || [];
			console.log(
				`Processing manifest with ${commandManifests.length} command manifests`,
			);

			// Ensure output directory exists and is empty
			if (fs.existsSync(outputDir)) {
				console.log(`Emptying output directory: ${outputDir}`);
				this.emptyDirectory(outputDir);
			} else {
				fs.mkdirSync(outputDir, { recursive: true });
			}

			// Generate all command forms using EJS templates
			const commandForms = await this.generateCommandForms(
				commandManifests,
				globalManifest,
				templateDir,
			);

			// Generate the main SPA using EJS template
			await this.generateSPA(
				globalManifest,
				commandManifests,
				commandForms,
				outputDir,
				templateDir,
			);

			// Generate client-side JavaScript
			await this.generateClientSideJavaScript(
				globalManifest,
				commandManifests,
				outputDir,
				templateDir,
			);

			// Copy CSS file
			await this.copyCSSFile(templateDir, outputDir);

			console.log(`EJS-based UI generated successfully at: ${outputDir}`);
			console.log('UI generation completed!');
		} catch (error) {
			console.error('Error during EJS-based UI generation:', error);
			throw error;
		}
	}

	/**
	 * Generate all command forms using EJS templates
	 * @param {Array} commandManifests - Array of command manifests
	 * @param {Object} globalManifest - Global manifest for state defaults
	 * @param {string} templateDir - Path to templates directory
	 * @returns {Promise<Array>} Array of rendered command form HTML
	 */
	async generateCommandForms(commandManifests, globalManifest, templateDir) {
		const commandForms = [];
		const initialState = globalManifest.stateDefaults || {};

		for (const command of commandManifests) {
			try {
				const formHtml = await this.renderCommandForm(
					command,
					initialState,
					templateDir,
				);
				commandForms.push(formHtml);
			} catch (error) {
				console.error(
					`Error generating form for command ${command.name}:`,
					error,
				);
				throw error;
			}
		}

		return commandForms;
	}

	/**
	 * Render a single command form using EJS template
	 * @param {Object} command - Command manifest
	 * @param {Object} state - Current state for runtime fallbacks
	 * @param {string} templateDir - Path to templates directory
	 * @returns {Promise<string>} Rendered HTML for the command form
	 */
	async renderCommandForm(command, state, templateDir) {
		const formTemplatePath = path.join(templateDir, 'command-form.ejs');

		if (!fs.existsSync(formTemplatePath)) {
			throw new Error(`Command form template not found: ${formTemplatePath}`);
		}

		const template = fs.readFileSync(formTemplatePath, 'utf8');

		// Generate parameter fields for this command
		const parameterFields = await this.generateParameterFields(
			command,
			state,
			templateDir,
		);

		const data = {
			command: command,
			parameterFields: parameterFields,
			formSubmitButton: 'Execute Command',
		};

		return ejs.render(template, data);
	}

	/**
	 * Generate parameter fields for a command using EJS template
	 * @param {Object} command - Command manifest
	 * @param {Object} state - Current state for runtime fallbacks
	 * @param {string} templateDir - Path to templates directory
	 * @returns {Promise<string>} Rendered HTML for all parameter fields
	 */
	async generateParameterFields(command, state, templateDir) {
		const paramTemplatePath = path.join(templateDir, 'param-field.ejs');

		if (!fs.existsSync(paramTemplatePath)) {
			throw new Error(
				`Parameter field template not found: ${paramTemplatePath}`,
			);
		}

		const template = fs.readFileSync(paramTemplatePath, 'utf8');
		let allParameterFields = '';

		for (const paramName in command.parameters || {}) {
			const param = command.parameters[paramName];
			param.name = paramName; // Ensure name is available

			// Calculate default value considering runtime fallbacks
			const defaultValue = this.getParameterDefaultValue(param, state);

			const data = {
				param: param,
				defaultValue: defaultValue,
			};

			const fieldHtml = ejs.render(template, data);
			allParameterFields += fieldHtml;
		}

		return allParameterFields;
	}

	/**
	 * Get default value for a parameter considering runtime fallbacks
	 * @param {Object} param - Parameter definition
	 * @param {Object} state - Current state object
	 * @returns {any} Default value
	 */
	getParameterDefaultValue(param, state) {
		// First check for runtime fallback
		if (
			param.runtimeFallback &&
			state &&
			state[param.runtimeFallback] !== undefined
		) {
			return state[param.runtimeFallback];
		}

		// Otherwise use default from manifest
		if (param.default !== undefined) {
			return param.default;
		}

		return undefined;
	}

	/**
	 * Generate the main SPA HTML using EJS template
	 * @param {Object} globalManifest - Global manifest
	 * @param {Array} commandManifests - Array of command manifests
	 * @param {Array} commandForms - Array of rendered command form HTML
	 * @param {string} outputDir - Output directory
	 * @param {string} templateDir - Templates directory
	 */
	async generateSPA(
		globalManifest,
		commandManifests,
		commandForms,
		outputDir,
		templateDir,
	) {
		const baseTemplatePath = path.join(templateDir, 'spa-base.ejs');

		if (!fs.existsSync(baseTemplatePath)) {
			throw new Error(`SPA base template not found: ${baseTemplatePath}`);
		}

		const template = fs.readFileSync(baseTemplatePath, 'utf8');

		const data = {
			htmlTitle: globalManifest.name || 'Command Interface',
			pageHeader: globalManifest.description || 'Command Interface',
			commandSelectorLabel: 'Select Command:',
			commands: commandManifests,
			commandForms: commandForms.join('\n'),
		};

		const renderedHtml = ejs.render(template, data);
		const htmlFilePath = path.join(outputDir, 'index.html');
		fs.writeFileSync(htmlFilePath, renderedHtml);

		console.log(`Generated main SPA: ${htmlFilePath}`);
	}

	/**
	 * Generate client-side JavaScript file
	 * @param {Object} globalManifest - Global manifest
	 * @param {Array} commandManifests - Array of command manifests
	 * @param {string} outputDir - Output directory
	 * @param {string} templateDir - Templates directory
	 */
	async generateClientSideJavaScript(
		globalManifest,
		commandManifests,
		outputDir,
		templateDir,
	) {
		const jsTemplatePath = path.join(templateDir, 'app.js.ejs');

		if (!fs.existsSync(jsTemplatePath)) {
			throw new Error(`JavaScript template not found: ${jsTemplatePath}`);
		}

		const template = fs.readFileSync(jsTemplatePath, 'utf8');

		const data = {
			initialState: globalManifest.stateDefaults || {},
			commands: commandManifests,
		};

		const renderedJS = ejs.render(template, data);
		const jsFilePath = path.join(outputDir, 'app.js');
		fs.writeFileSync(jsFilePath, renderedJS);

		console.log(`Generated client-side JavaScript: ${jsFilePath}`);
	}

	/**
	 * Copy CSS file to output directory
	 * @param {string} templateDir - Templates directory
	 * @param {string} outputDir - Output directory
	 */
	async copyCSSFile(templateDir, outputDir) {
		const cssSourcePath = path.join(templateDir, 'global.css');
		const cssDestPath = path.join(outputDir, 'app.css');

		if (fs.existsSync(cssSourcePath)) {
			fs.copyFileSync(cssSourcePath, cssDestPath);
			console.log(`Copied CSS file: ${cssDestPath}`);
		} else {
			console.warn(`CSS file not found at: ${cssSourcePath}`);
		}
	}

	/**
	 * Empty a directory by removing all files and subdirectories
	 * @param {string} dirPath - Path to the directory to empty
	 */
	emptyDirectory(dirPath) {
		const items = fs.readdirSync(dirPath);

		for (const item of items) {
			const itemPath = path.join(dirPath, item);
			const stat = fs.statSync(itemPath);

			if (stat.isDirectory()) {
				this.emptyDirectory(itemPath);
				fs.rmdirSync(itemPath);
			} else {
				fs.unlinkSync(itemPath);
			}
		}
	}
}


================================================================================

<!-- File: generate\templates\app.js.ejs -->

// File: templates/app.js.ejs

// Client-side JavaScript for EJS-generated UI
(function() {
    'use strict';
    
    // Initialize state from global defaults
    let state = <%- JSON.stringify(initialState, null, 2) %>;
    
    // Available commands
    const commands = <%- JSON.stringify(commands, null, 2) %>;
    
    // Map of command manifests by name for quick lookup
    const commandManifests = {};
    commands.forEach(cmd => {
        commandManifests[cmd.name] = cmd;
    });
    
    // DOM elements
    const commandSelector = document.getElementById('commandSelector');
    const formsContainer = document.getElementById('formsContainer');
    const resultsContainer = document.getElementById('resultsContainer');
    const resultsContent = document.getElementById('resultsContent');
    
    // Show a specific form and hide others
    function showForm(commandName) {
        // Hide all forms
        document.querySelectorAll('.form-container').forEach(form => {
            form.classList.remove('active-form');
        });
        
        // Show the selected form if it exists
        if (commandName) {
            const form = document.getElementById(commandName + '-form');
            if (form) {
                form.classList.add('active-form');
            }
        }
    }
    
    // Handle command selection change
    commandSelector.addEventListener('change', function(e) {
        const commandName = e.target.value;
        showForm(commandName);
        
        // Scroll to the form
        if (commandName) {
            const form = document.getElementById(commandName + '-form');
            if (form) {
                form.scrollIntoView({ behavior: 'smooth' });
            }
        }
    });
    
    // Handle form submissions
    document.addEventListener('submit', function(e) {
        if (e.target.classList.contains('command-form')) {
            e.preventDefault();
            handleCommandSubmit(e.target);
        }
    });
    
    // Process a command form submission
    async function handleCommandSubmit(form) {
        const commandName = form.getAttribute('data-command');
        if (!commandName) return;
        
        const cmdManifest = commandManifests[commandName];
        if (!cmdManifest) {
            showResults({ error: 'Command not found: ' + commandName }, 'error');
            return;
        }
        
        // Extract form data
        const args = {};
        const paramManifests = cmdManifest.parameters || {};
        
        for (const paramName in paramManifests) {
            const param = paramManifests[paramName];
            param.name = paramName;
            
            // Find the field within the current form
            const field = form.querySelector('[data-param-name="' + param.name + '"]');
            let value;
            
            if (field) {
                // Extract value from the form field
                if (field.type === 'checkbox') {
                    value = field.checked;
                } else if (field.type === 'number') {
                    value = field.value ? Number(field.value) : (param.required ? 0 : undefined);
                } else if (field.type === 'select-multiple') {
                    // Handle multi-select
                    const selectedOptions = Array.from(field.selectedOptions);
                    value = selectedOptions.map(option => option.value);
                } else {
                    value = field.value !== undefined ? field.value : (field.textContent || field.innerText);
                    
                    // Handle array inputs (comma-separated values)
                    if (param.type === 'array' && value) {
                        value = value.split(',').map(v => v.trim()).filter(v => v);
                    }
                }
            }
            
            // Apply runtime fallback only if the field value is empty/undefined and a fallback exists
            if ((value === undefined || value === '' || value === null) && param.runtimeFallback && state[param.runtimeFallback] !== undefined) {
                value = state[param.runtimeFallback];
            }
            
            // For checkboxes, we should always include the value (true/false), otherwise only add to args if value exists and is not empty
            if (field && field.type === 'checkbox') {
                args[param.name] = value || false;
            } else if (value !== undefined && value !== '' && value !== null) {
                args[param.name] = value;
            }
        }
        
        // Prepare command object
        const command = {
            name: commandName,
            args: args
        };
        
        console.log('Executing command:', command);
        
        try {
            // Execute the command
            const result = await executeCommand(command);
            
            // Update state based on side effects
            state = updateState(state, command, result, cmdManifest);
            
            // Show results
            showResults(result, result.error ? 'error' : 'success');
        } catch (error) {
            showResults({ error: 'Execution Error: ' + error.message }, 'error');
        }
    }
    
    // Validate a command (simplified - would use actual validation in real implementation)
    function validateCommand(command, cmdManifest) {
        return {
            isValid: true,
            errors: []
        };
    }
    
    // Update state based on command side effects (simplified)
    function updateState(state, command, result, cmdManifest) {
        // This is a simplified version - in a real implementation, 
        // you would use proper state management
        return Object.assign({}, state);
    }
    
    // API execution function that makes HTTP requests or uses Electron IPC
    async function executeCommand(command) {
        // More thorough check for Electron environment
        const isElectron = window && window.electronAPI && typeof window.electronAPI.executeCommand === 'function';
        
        if (isElectron) {
            // Use IPC to send command to main process
            try {
                const result = await window.electronAPI.executeCommand(command);
                return result;
            } catch (error) {
                // Fallback to HTTP if IPC fails
            }
        }
        
        // Make HTTP API call to the /api endpoint (default behavior if not in Electron or if IPC failed)
        try {
            // First, try POST request with JSON body
            const response = await fetch('/api', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    json: JSON.stringify(command)
                })
            });
            
            if (!response.ok) {
                let errorText = 'HTTP Error: ' + response.status;
                try {
                    const errorData = await response.json();
                    if (errorData.error) {
                        errorText = errorData.error;
                    }
                } catch (e) {
                    errorText = response.statusText || errorText;
                }
                throw new Error(errorText);
            }
            
            const result = await response.json();
            return result;
        } catch (postError) {
            // If POST fails, try GET request as fallback
            try {
                const urlParams = new URLSearchParams({
                    json: JSON.stringify(command)
                });
                
                const response = await fetch('/api?' + urlParams.toString());
                
                if (!response.ok) {
                    let errorText = 'HTTP Error: ' + response.status;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) {
                            errorText = errorData.error;
                        }
                    } catch (e) {
                        errorText = response.statusText || errorText;
                    }
                    throw new Error(errorText);
                }
                
                const result = await response.json();
                return result;
            } catch (getError) {
                throw getError;
            }
        }
    }
    
    // Show results in the results container
    function showResults(result, type = 'success') {
        resultsContainer.classList.remove('hidden', 'error', 'success');
        
        // Determine the appropriate type and content to display
        if (result.error) {
            resultsContainer.classList.add('error');
            resultsContent.innerHTML = '<strong>Error:</strong><br><code>' + escapeHtml(result.error) + '</code>';
        } else if (result.output) {
            resultsContainer.classList.add('success');
            // Format output, handling newlines properly
            let formattedOutput = escapeHtml(result.output).replace(/\n/g, '<br>');
            resultsContent.innerHTML = '<strong>Output:</strong><br><code>' + formattedOutput + '</code>';
        } else {
            // If no specific error or output, show the full result for debugging
            resultsContainer.classList.add(type);
            resultsContent.innerHTML = '<pre>' + JSON.stringify(result, null, 2) + '</pre>';
        }
    }
    
    // Escape HTML special characters to prevent XSS
    function escapeHtml(str) {
        if (typeof str !== 'string') return String(str);
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    
    // Initialize - hide all forms initially
    showForm('');
    
    console.log('EJS-generated UI initialized with', commands.length, 'commands');
})();

================================================================================

<!-- File: generate\templates\command-form.ejs -->

<div
	id="<%= command.name %>-form"
	class="form-container"
	data-command-form="<%= command.name %>"
>
	<h2><%= command.name %></h2>
	<p><%= command.description || '' %></p>

	<form class="command-form" data-command="<%= command.name %>">
		<%- parameterFields %>

		<button type="submit" class="btn btn-block"><%= formSubmitButton || 'Execute Command' %></button>
	</form>

	<% if (command.examples && command.examples.length > 0) { %>
		<div class="command-examples">
			<h4>Examples:</h4>
			<ul>
				<% command.examples.forEach(function(example) { %>
					<li><pre><code><%- example %></code></pre></li>
				<% }); %>
			</ul>
		</div>
	<% } %>
</div>

================================================================================

<!-- File: generate\templates\global.css -->

:root {
	--primary-color: #3498db;
	--secondary-color: #2c3e50;
	--success-color: #27ae60;
	--warning-color: #f39c12;
	--danger-color: #e74c3c;
	--light-color: #f8f9fa;
	--dark-color: #343a40;
	--border-color: #ddd;
	--shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
	line-height: 1.5;
	color: #333;
	background-color: #f5f7fa;
	padding: 10px;
}

.container {
	max-width: 1200px;
	margin: 0 auto;
	background: white;
	border-radius: 6px;
	box-shadow: var(--shadow);
	overflow: hidden;
}

header {
	background: var(--secondary-color);
	color: white;
	padding: 12px 15px;
	text-align: center;
}

header h1 {
	margin-bottom: 3px;
	font-size: 1.4em;
}

.main-content {
	display: flex;
	flex-direction: column;
	padding: 12px;
}

@media (min-width: 768px) {
	.main-content {
		flex-direction: row;
	}
}

.sidebar {
	width: 100%;
	padding: 12px;
	border-right: 1px solid var(--border-color);
	margin-bottom: 12px;
}

@media (min-width: 768px) {
	.sidebar {
		width: 220px;
		margin-bottom: 0;
	}
}

.content {
	flex: 1;
	padding: 12px;
}

.command-selector {
	width: 100%;
	padding: 8px;
	border: 1px solid var(--border-color);
	border-radius: 4px;
	background: white;
	font-size: 14px;
}

.form-container {
	display: none;
}

.form-container.active-form {
	display: block;
}

.form-group {
	margin-bottom: 12px;
}

label {
	display: block;
	margin-bottom: 4px;
	font-weight: bold;
	color: var(--secondary-color);
	font-size: 0.95em;
}

.param-description {
	display: block;
	font-weight: normal;
	font-size: 0.85em;
	color: #666;
	margin-top: 1px;
}

input,
select,
textarea {
	width: 100%;
	padding: 7px 8px;
	border: 1px solid var(--border-color);
	border-radius: 4px;
	font-size: 14px;
}

input[type='checkbox'] {
	width: auto;
	margin-right: 5px;
}

textarea {
	min-height: 80px;
	resize: vertical;
}

.validation-info {
	font-size: 0.8em;
	color: #666;
	margin-top: 3px;
}

.array-format-help,
.union-type-help {
	font-size: 0.8em;
	color: #666;
	margin-top: 3px;
	font-style: italic;
}

.btn {
	display: inline-block;
	padding: 8px 16px;
	background: var(--primary-color);
	color: white;
	border: none;
	border-radius: 4px;
	cursor: pointer;
	font-size: 14px;
	text-align: center;
	margin-top: 8px;
}

.btn:hover {
	background: #2980b9;
}

.btn-block {
	display: block;
	width: 100%;
}

.results {
	margin-top: 20px;
	padding: 12px;
	background: var(--light-color);
	border-radius: 4px;
	border-left: 3px solid var(--primary-color);
}

.results.error {
	border-left-color: var(--danger-color);
}

.results.success {
	border-left-color: var(--success-color);
}

.hidden {
	display: none;
}

.command-info {
	margin-top: 15px;
	padding: 10px;
	background: #e8f4fc;
	border-radius: 4px;
	font-size: 0.9em;
}

.command-examples {
	margin-top: 12px;
}

.command-examples pre {
	background: #2c3e50;
	color: white;
	padding: 8px;
	border-radius: 4px;
	overflow-x: auto;
	font-size: 0.85em;
}

================================================================================

<!-- File: generate\templates\param-field.ejs -->

<!-- File: templates/param-field.ejs -->

<div class="form-group">
    <label for="<%= param.name %>">
        <%= param.name %><%= param.required ? ' *' : '' %>
        <% if (param.description) { %>
            <span class="param-description"><%= param.description %></span>
        <% } %>
    </label>
    <%
    // Determine the input type based on parameter configuration
    if (param.enum) {
        // Enum parameter - render as select dropdown
    %>
        <select name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" <%= param.required ? 'required' : '' %> <% if (param.description) { %>title="<%- param.description %>"<% } %>>
            <% param.enum.forEach(function(option) { %>
                <option value="<%= option %>" <%= (defaultValue !== undefined && option == defaultValue) ? 'selected' : '' %>><%= option %></option>
            <% }); %>
        </select>
    <%
    } else if (param.type === 'boolean') {
        // Boolean parameter - render as checkbox
    %>
        <input type="checkbox" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" <%= (defaultValue !== undefined && defaultValue === true) ? 'checked' : '' %> <% if (param.description) { %>title="<%- param.description %>"<% } %>>
    <%
    } else if (param.type === 'integer' || param.type === 'number') {
        // Number parameter - render as number input
    %>
        <input type="number" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <% if (defaultValue !== undefined) { %>value="<%- defaultValue %>"<% } %> 
            <%= param.required ? 'required' : '' %> 
            <% if (param.min !== undefined) { %>min="<%- param.min %>"<% } %> 
            <% if (param.max !== undefined) { %>max="<%- param.max %>"<% } %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
    <%
    } else if (param.type === 'array') {
        // Array parameter - text input with comma-separated values
        let arrayValue = '';
        if (defaultValue !== undefined) {
            if (Array.isArray(defaultValue)) {
                arrayValue = defaultValue.join(', ');
            } else {
                arrayValue = String(defaultValue);
            }
        }
    %>
        <input type="text" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <% if (arrayValue) { %>value="<%- arrayValue %>"<% } %> 
            <%= param.required ? 'required' : '' %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
        <div class="array-format-help">Enter comma-separated values (e.g., value1, value2, value3)</div>
    <%
    } else if (param.description && param.description.length > 100) {
        // Long description - use textarea
    %>
        <textarea name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <%= param.required ? 'required' : '' %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
            <% if (defaultValue !== undefined) { %><%- defaultValue %><% } %>
        </textarea>
    <%
    } else {
        // Default - string input
    %>
        <input type="text" name="<%= param.name %>" id="<%= param.name %>" data-param-name="<%= param.name %>" 
            <% if (defaultValue !== undefined) { %>value="<%- defaultValue %>"<% } %> 
            <%= param.required ? 'required' : '' %> 
            <% if (param.description) { %>title="<%- param.description %>"<% } %>>
    <%
    }
    %>
</div>

================================================================================

<!-- File: generate\templates\spa-base.ejs -->

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title><%= htmlTitle || 'Command Interface' %></title>
		<link rel="stylesheet" href="app.css">
	</head>
	<body>
		<div class="container">
			<header>
				<h1><%= pageHeader || 'Command Interface' %></h1>
				<p>Execute commands through a web interface</p>
			</header>

			<div class="main-content">
				<div class="sidebar">
					<div>
						<label for="commandSelector"><%= commandSelectorLabel || 'Select Command:' %></label>
						<select id="commandSelector" class="command-selector">
							<option value="">Select a command...</option>
							<% commands.forEach(function(cmd) { %>
								<option value="<%= cmd.name %>"><%= cmd.name %></option>
							<% }); %>
						</select>
					</div>
				</div>

				<div class="content">
					<!-- Command forms will be inserted here -->
					<div id="formsContainer">
						<%- commandForms %>
					</div>

					<div id="resultsContainer" class="results hidden">
						<h3>Command Results</h3>
						<div id="resultsContent"></div>
					</div>
				</div>
			</div>
		</div>

		<script src="app.js"></script>
	</body>
</html>

================================================================================

<!-- File: http\commands.json -->

{
  "http": {
    "commandType": "kernel-plugin",
    "methodName": "start", 
    "description": "Start HTTP server serving UI and API",
    "parameters": {
      "serverPort": {
        "type": "integer",
        "required": false, 
        "runtimeFallback": "serverPort",
        "description": "Port number for the server"
      },
      "servedUIDir": {
        "type": "string",
        "required": false,
        "runtimeFallback": "servedUIDir",
        "description": "Directory containing UI files to serve"
      },
      "apiEndpoint": {
        "type": "string",
        "required": false,
        "runtimeFallback": "apiEndpoint", 
        "description": "API endpoint path"
      }
    }
  }
}

================================================================================

<!-- File: http\contract.json -->

{
  "name": "http-plugin", 
  "version": "0.0.0",
  "description": "HTTP Server with UI & API Endpoints",
  "stateDefaults": {
    "servedUIDir": "./generated-ui",
    "apiEndpoint": "/api",
    "serverPort": 8080,
    "isServerRunning": false,
    "totalRequests": 0
  }
}

================================================================================

<!-- File: http\help.json -->

{
  "http": {
    "examples": [
      "http()",
      "http(serverPort=3000)",
      "http(servedUIDir=\"./dist\", apiEndpoint=\"/api/v1\")"
    ],
    "notes": "Serves both static UI files and REST API. Requires UI files to be generated first."
  }
}

================================================================================

// File: http\HTTP.js

import { URL } from 'url';
import http from 'http';
import fs from 'fs';
import path from 'path';

export class HTTPServer {
	constructor() {
		this.commandProcessor = null; // Will be initialized in start method
	}

	start(port, servedUIDir, apiEndpoint, commandProcessor) {
		// Validate parameters
		if (typeof port !== 'number' || port <= 0) {
			throw new Error('port parameter must be a positive number');
		}

		if (servedUIDir && typeof servedUIDir !== 'string') {
			throw new Error('servedUIDir parameter must be a string if provided');
		}

		if (apiEndpoint && typeof apiEndpoint !== 'string') {
			throw new Error('apiEndpoint parameter must be a string if provided');
		}

		if (!commandProcessor || typeof commandProcessor.processCommand !== 'function') {
			throw new Error(
				'commandProcessor parameter must be a valid command processor instance',
			);
		}

		// Initialize properties with explicit parameters
		this.port = port;
		this.staticDir = servedUIDir;
		this.apiEndpoint = apiEndpoint;
		this.commandProcessor = commandProcessor;

		return new Promise((resolve, reject) => {
			const server = http.createServer(async (req, res) => {
				// Add CORS headers
				res.setHeader('Access-Control-Allow-Origin', '*');
				res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
				res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

				if (req.method === 'OPTIONS') {
					res.writeHead(200);
					res.end();
					return;
				}

				// Route to API endpoint if matches
				if (req.url.startsWith(this.apiEndpoint)) {
					await this.handleAPIRequest(req, res);
					return;
				}

				// Serve static files if directory is configured
				if (this.staticDir) {
					await this.handleStaticRequest(req, res);
					return;
				}

				// Default to 404 if no static dir configured and not API
				res.writeHead(404, { 'Content-Type': 'application/json' });
				res.end(JSON.stringify({ error: 'Not found' }));
			});

			server.listen(this.port, () => {
				console.log(`🔗 HTTP server running on port ${this.port}`);
				if (this.staticDir) {
					console.log(`   Serving static files from: ${this.staticDir}`);
				}
				console.log(
					`   API available at: http://localhost:${this.port}${this.apiEndpoint}`,
				);
				if (this.staticDir) {
					console.log(`   UI available at: http://localhost:${this.port}/`);
				}
				resolve(server);
			});

			server.on('error', (err) => {
				console.error('Server error:', err.message);
				reject(err);
			});
		});
	}

	async handleAPIRequest(req, res) {
		try {
			const parsedUrl = new URL(req.url, `http://${req.headers.host}`);
			let commandString;

			if (req.method === 'GET') {
				commandString = parsedUrl.searchParams.get('command');
				if (!commandString) {
					// Fallback to 'json' parameter to maintain backward compatibility
					commandString = parsedUrl.searchParams.get('json');
				}
				if (commandString) {
					return await this.executeCommandAndRespond(commandString, res);
				}
				// If no command parameter, return 400
				return this.sendErrorResponse(res, "Missing 'command' parameter", 400);
			}

			if (req.method === 'POST') {
				let body = '';
				req.on('data', (chunk) => (body += chunk));
				req.on('end', async () => {
					try {
						const contentType = req.headers['content-type'] || '';

						if (contentType.includes('application/x-www-form-urlencoded')) {
							const params = new URLSearchParams(body);
							commandString = params.get('command') || params.get('json'); // backward compatibility
						} else if (contentType.includes('application/json')) {
							const json = JSON.parse(body);
							commandString = json?.command || json?.json; // backward compatibility
						}

						if (commandString) {
							await this.executeCommandAndRespond(commandString, res);
						} else {
							this.sendErrorResponse(
								res,
								"Missing 'command' in request body",
								400,
							);
						}
					} catch (err) {
						this.sendErrorResponse(
							res,
							`Invalid POST body: ${err.message}`,
							400,
						);
					}
				});
				return;
			}

			this.sendErrorResponse(res, 'Method not allowed', 405);
		} catch (err) {
			console.error('API handler error:', err);
			this.sendErrorResponse(res, `Internal server error: ${err.message}`, 500);
		}
	}

	async executeCommandAndRespond(commandString, res) {
		try {
			// Process command using the shared processor
			const result = await this.commandProcessor.processCommand(commandString);
			return this.sendResponse(res, result);
		} catch (err) {
			console.error('Command execution error:', err);
			return this.sendErrorResponse(res, err.message, 500);
		}
	}

	/**
	 * Send a response with appropriate status code
	 * @param {Object} res - HTTP response object
	 * @param {Object} result - Command result object
	 * @param {number} defaultStatusCode - Default status code if not in result
	 */
	sendResponse(res, result) {
		if (result.error) {
			return this.sendErrorResponse(res, result.error, 400);
		}

		res.writeHead(200, { 'Content-Type': 'application/json' });
		res.end(JSON.stringify(result));
	}

	/**
	 * Send an error response
	 * @param {Object} res - HTTP response object
	 * @param {string} errorMessage - Error message
	 * @param {number} statusCode - HTTP status code
	 */
	sendErrorResponse(res, errorMessage, statusCode = 400) {
		res.writeHead(statusCode, { 'Content-Type': 'application/json' });
		res.end(JSON.stringify({ error: errorMessage }));
	}

	async handleStaticRequest(req, res) {
		// Check if static directory is configured
		if (!this.staticDir) {
			return this.sendErrorResponse(
				res,
				'Static file serving not configured',
				404,
			);
		}

		// Check if the static directory exists and has index.html
		const indexPath = path.join(this.staticDir, 'index.html');
		if (!fs.existsSync(this.staticDir) || !fs.existsSync(indexPath)) {
			return this.sendErrorResponse(
				res,
				`Directory '${this.staticDir}' does not exist or is missing index.html. Please generate UI files first using 'node kernel.js --generate'`,
				404,
			);
		}

		// Remove query parameters and normalize path
		const url = new URL(req.url, `http://${req.headers.host}`);
		let filePath = url.pathname;

		// Default to index.html for root path
		if (filePath === '/' || filePath === '') {
			filePath = '/index.html';
		}

		// Resolve to absolute path and prevent directory traversal
		const safePath = path.normalize(filePath).replace(/^(\.\.[\/\\])+/, '');
		const fullPath = path.join(this.staticDir, safePath);

		// Check if the requested path is within the static directory
		if (!fullPath.startsWith(this.staticDir)) {
			res.writeHead(403, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: 'Forbidden' }));
			return;
		}

		// Check if file exists
		if (!fs.existsSync(fullPath)) {
			// Try index.html for SPA routing
			const indexPath = path.join(this.staticDir, 'index.html');
			if (fs.existsSync(indexPath)) {
				this.serveFile(indexPath, res);
				return;
			}

			res.writeHead(404, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: 'File not found' }));
			return;
		}

		this.serveFile(fullPath, res);
	}

	serveFile(filePath, res) {
		const ext = path.extname(filePath).toLowerCase();
		const contentType = this.getContentType(ext);

		fs.readFile(filePath, (err, content) => {
			if (err) {
				res.writeHead(500);
				res.end('Server Error');
			} else {
				res.writeHead(200, { 'Content-Type': contentType });
				res.end(content);
			}
		});
	}

	getContentType(ext) {
		const types = {
			'.html': 'text/html',
			'.css': 'text/css',
			'.js': 'application/javascript',
			'.json': 'application/json',
			'.png': 'image/png',
			'.jpg': 'image/jpeg',
			'.jpeg': 'image/jpeg',
			'.gif': 'image/gif',
			'.svg': 'image/svg+xml',
			'.ico': 'image/x-icon',
		};
		return types[ext] || 'application/octet-stream';
	}

	async respond(jsonString, res) {
		if (typeof jsonString === 'undefined') {
			res.writeHead(400, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: "Missing 'json' parameter" }));
			return;
		}

		try {
			const result = await this.apiHandler.handleInput(jsonString);

			if (result.error) {
				res.writeHead(400, { 'Content-Type': 'application/json' });
				res.end(JSON.stringify({ error: result.error }));
				return;
			}

			res.writeHead(200, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify(result));
		} catch (err) {
			res.writeHead(500, { 'Content-Type': 'application/json' });
			res.end(JSON.stringify({ error: err.message }));
		}
	}
}


================================================================================

// File: http\index.js

import { HTTPServer } from './HTTP.js';
import path from 'path';
import { pathToFileURL } from 'url';

/**
 * HTTP plugin wrapper
 * Encapsulates the HTTP plugin instantiation and exposes functional interface
 */

// Plugin instance (singleton)
let httpInstance = null;

/**
 * Initialize and get the HTTP instance
 * @returns {HTTPServer} HTTP plugin instance
 */
function getHttpInstance() {
	if (!httpInstance) {
		httpInstance = new HTTPServer();
	}
	return httpInstance;
}

/**
 * Start the HTTP server plugin
 * @param {number} port - Port number for the server
 * @param {string} servedUIDir - Directory to serve static UI files from
 * @param {string} apiEndpoint - API endpoint path
 * @param {Object} commandProcessor - Command processor instance
 * @returns {Promise<void>}
 */
export async function start(kernelPath, projectRoot, port, servedUIDir, apiEndpoint) {
	const manifestUrl = pathToFileURL(path.join(kernelPath, 'contract.js')).href;
	const { manifestReader } = await import(manifestUrl);
	const manifest = manifestReader(projectRoot);
	const commandProcessorUrl = pathToFileURL(path.join(kernelPath, 'processor/CommandProcessor.js')).href;
	const { CommandProcessor } = await import(commandProcessorUrl);
	const commandProcessor = new CommandProcessor(
		projectRoot,
		manifest
	);
	const httpServer = getHttpInstance();
	return await httpServer.start(port, servedUIDir, apiEndpoint, commandProcessor);
}

/**
 * Expose the plugin's start method for direct usage
 */
export default {
	start,
};


================================================================================

<!-- File: http\runtime.json -->

{
  "http": {
    "sideEffects": {
      "setState": {
        "servedUIDir": {"fromParam": "servedUIDir"},
        "serverPort": {"fromParam": "serverPort"}, 
        "apiEndpoint": {"fromParam": "apiEndpoint"},
        "isServerRunning": true,
        "currentMode": "http",
        "lastOperation": {"template": "started_http_on_port_{{serverPort}}"}
      }
    },
    "successOutput": "🌐 HTTP server running!\n   UI: http://localhost:{{serverPort}}/\n   API: http://localhost:{{serverPort}}{{apiEndpoint}}\n   Serving: {{servedUIDir}}"
  }
}

================================================================================

