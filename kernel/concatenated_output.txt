// File: app.js

import { manifest } from './contract.js';
import { buildConfig } from './utils/config-loader.js';
import { CommandProcessor } from './processor/CommandProcessor.js';
import { pluginLoader } from './utils/PluginLoader.js';

/**
 * Launch the hosted application (Markov text generator) with the given arguments and project root
 * @param {string[]} args - Command line arguments
 * @param {string} projectRoot - The project root directory
 * @returns {Promise<void>}
 */
export async function launch(args, projectRoot) {
	// Build unified configuration once at the beginning
	const config = buildConfig(projectRoot);
	const commandProcessor = new CommandProcessor(config, manifest);

	// Get the repl and cli plugins using the plugin loader
	const replStart = await pluginLoader.getPluginMethod('repl', 'start');
	const cliRun = await pluginLoader.getPluginMethod('cli', 'run');

	if (!replStart || !cliRun) {
		console.error('❌ repl or cli plugin not found or invalid');
		process.exit(1);
	}

	// Default to REPL mode if no args or if args are application-specific
	if (args.length === 0) {
		// Default to REPL mode if no args
		return replStart(config, commandProcessor);
	} else {
		// Check if we're being called directly with command line args
		return cliRun(config, commandProcessor, args);
	}
}

// Note: This file is not meant to be run directly. Use main.js in the project root.


================================================================================

// File: contract.js

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import pathResolver from './utils/path-resolver.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Synchronously load and cache all manifests at module initialization
let contractCache = null;

function initializeContractSync() {
	if (contractCache) {
		return contractCache;
	}

	// Load global manifest from contract directory using path resolver
	const globalManifest = JSON.parse(
		fs.readFileSync(
			path.join(pathResolver.getContractDir(), 'global.json'),
			'utf8',
		),
	);

	// Get all command directories from the contract folder using path resolver
	const contractDir = pathResolver.getContractDir();
	const items = fs.readdirSync(contractDir, { withFileTypes: true });
	const commandDirs = items
		.filter(
			(dirent) =>
				dirent.isDirectory() &&
				dirent.name !== 'index.js' &&
				dirent.name !== 'global.json' &&
				dirent.name !== 'exit' && // Filter out built-in commands
				dirent.name !== 'help',
		) // Filter out built-in commands
		.map((dirent) => dirent.name);

	// Load all manifest slices synchronously
	const commands = [];

	for (const dir of commandDirs) {
		try {
			// Load manifest slice from contract directory
			const manifestPath = path.join(contractDir, dir, 'manifest.json');
			let manifestSlice = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));

			// Load runtime slice if it exists
			const runtimePath = path.join(contractDir, dir, 'runtime.json');
			let runtimeSlice = {};
			if (fs.existsSync(runtimePath)) {
				runtimeSlice = JSON.parse(fs.readFileSync(runtimePath, 'utf8'));
			}

			// Load help slice if it exists
			const helpPath = path.join(contractDir, dir, 'help.json');
			let helpSlice = {};
			if (fs.existsSync(helpPath)) {
				helpSlice = JSON.parse(fs.readFileSync(helpPath, 'utf8'));
			}

			// Deep merge parameters objects, preserving all properties from all three
			const mergedParameters = {};
			// First, add all parameters from the base manifest
			for (const paramName in manifestSlice.parameters || {}) {
				mergedParameters[paramName] = {
					...manifestSlice.parameters[paramName],
				};
			}
			// Then, add/extend with parameters from runtime.json
			for (const paramName in runtimeSlice.parameters || {}) {
				if (mergedParameters[paramName]) {
					// Merge parameter properties
					mergedParameters[paramName] = {
						...mergedParameters[paramName],
						...runtimeSlice.parameters[paramName],
					};
				} else {
					// Add new parameter from runtime
					mergedParameters[paramName] = {
						...runtimeSlice.parameters[paramName],
					};
				}
			}
			// Finally, add/extend with parameters from help.json
			for (const paramName in helpSlice.parameters || {}) {
				if (mergedParameters[paramName]) {
					// Merge parameter properties
					mergedParameters[paramName] = {
						...mergedParameters[paramName],
						...helpSlice.parameters[paramName],
					};
				} else {
					// Add new parameter from help
					mergedParameters[paramName] = { ...helpSlice.parameters[paramName] };
				}
			}

			// Create the merged manifest slice by combining all three
			let mergedManifestSlice = {
				...manifestSlice,
				...runtimeSlice,
				...helpSlice,
				parameters: mergedParameters,
			};

			// If this is an external-method command, resolve the module path ahead of time
			if (
				mergedManifestSlice.commandType === 'external-method' &&
				mergedManifestSlice.modulePath
			) {
				// Use the project root from the path resolver to resolve the module path
				const projectRoot = pathResolver.getProjectRoot();
				const absoluteModulePath = path.resolve(
					projectRoot,
					mergedManifestSlice.modulePath,
				);
				// Add the resolvedAbsolutePath to the manifest for use by the command handler
				mergedManifestSlice = {
					...mergedManifestSlice,
					resolvedAbsolutePath: absoluteModulePath,
				};
			}

			commands.push(mergedManifestSlice);
		} catch (error) {
			console.warn(`Warning: Could not load from ${dir}:`, error.message);
		}
	}

	const manifest = {
		...globalManifest,
		commands: commands,
	};

	contractCache = {
		manifest,
	};

	return contractCache;
}

// Initialize the contract synchronously at module load time for manifest
const { manifest } = initializeContractSync();

// Export only the manifest (this is what the processors need)
export { manifest };


================================================================================

// File: kernel.js

import { buildConfig } from './utils/config-loader.js';
import { manifest } from './contract.js';
import { CommandProcessor } from './processor/CommandProcessor.js';
import { pluginLoader } from './utils/PluginLoader.js';
import path from 'path';

/**
 * Launch the kernel infrastructure with the given arguments and project root
 * @param {string[]} args - Command line arguments
 * @param {string} projectRoot - The project root directory
 * @returns {Promise<void>}
 */
export async function launch(args, projectRoot) {
	// Build unified configuration once at the beginning
	const config = buildConfig(projectRoot);
	const commandProcessor = new CommandProcessor(config, manifest);

	// Check if we should run in Electron
	if (args.includes('--electron')) {
		// Get the electron plugin and start it using the plugin loader
		const electronPlugin = await pluginLoader.getPlugin('electron');
		if (!electronPlugin) {
			console.error('❌ Electron plugin not found or invalid');
			process.exit(1);
		}

		return electronPlugin.start(config, commandProcessor);
	}
	// Check if we should regenerate UI
	else if (args.includes('--generate')) {
		// Get the generator plugin and run it using the plugin loader
		const generatorPlugin = await pluginLoader.getPlugin('generator');
		if (!generatorPlugin) {
			console.error('❌ Generator plugin not found or invalid');
			process.exit(1);
		}

		return generatorPlugin
			.run(config, manifest, commandProcessor)
			.then(() => {
				console.log('✅ UI generation completed successfully!');
				process.exit(0);
			})
			.catch((err) => {
				console.error('❌ Failed to generate UI:', err.message);
				process.exit(1);
			});
	}
	// Check if we should start HTTP server (now serves both UI and API, like old --serve)
	else if (args.includes('--http')) {
		// Get the HTTP plugin and start server that serves both UI and API
		const httpPlugin = await pluginLoader.getPlugin('http');
		if (!httpPlugin) {
			console.error('❌ HTTP plugin not found or invalid');
			process.exit(1);
		}

		return httpPlugin.start(config, commandProcessor);
	} else {
		// For other kernel commands or to show help
		console.log('Kernel command-line interface');
		console.log('Available commands:');
		console.log('  --generate             Generate UI from contracts');
		console.log(
			'  --http[=port]          Serve UI and API on specified port (default 8080)',
		);
		console.log('  --electron             Launch Electron application');
		process.exit(0);
	}
}

// Note: This file is not meant to be run directly. Use kernel.js in the project root.


================================================================================

<!-- File: MANIFEST.md -->

# Manifest Definition and Guide

## Overview

Manifests are the core of the Markov-js kernel architecture, defining how commands are processed, validated, and executed. Each command is defined through a JSON manifest file that declares its parameters, behavior, and side effects.

## Global Manifest vs Command Manifests

There are two types of manifest files in the system:

1. **Global manifest** (`contract/global.json`) - Defines application-wide configuration
2. **Command manifests** (`contract/[command-name]/manifest.json`) - Defines individual command behavior

## Global Manifest Properties

### Required Properties

- `name` (string): The application name
- `version` (string): The application version
- `description` (string): Human-readable description of the application

### Optional Properties

- `prompt` (string): The REPL prompt string
- `stateDefaults` (object): Default values for application state

Example:

```json
{
	"name": "your-app-name",
	"version": "1.0.0",
	"description": "A description of your application",
	"prompt": "app> ",
	"stateDefaults": {
		"currentUser": null,
		"defaultFile": "default.txt"
	}
}
```

## Command Manifest Properties

### Required Properties

- `name` (string): The unique command identifier
- `commandType` (string): How the command is processed; one of:
  - `"external-method"`: Delegates to an external domain method
  - `"internal"`: Pure state manipulation defined in the manifest
  - `"custom"`: Requires a custom handler implementation
- `description` (string): Human-readable command description
- `parameters` (array): Array of parameter definitions (can be empty)

### Optional Properties

- `syntax` (string): Command usage syntax (e.g., `"myCommand(param1, [options])"`)
- `examples` (array): Usage examples for documentation
- `sideEffects` (object): State changes that occur after command execution

### Conditionally Required Properties

#### For "external-method" commands:

- `modulePath` (string): Path to the external module that contains the method to execute (resolved to absolute path at load time)
- `methodName` (string): Name of the method in the external module to execute

#### For "internal" commands:

- `successOutput` (string): Output template for user feedback (recommended)

## Parameter Properties

### Required Properties

- `name` (string): Parameter identifier
- `type` (string): Data type; one of:
  - `"string"`, `"integer"`, `"number"`, `"boolean"`, `"array"`
  - Union types using `|` (e.g., `"string|integer"`)
- `required` (boolean): Whether the parameter is mandatory

### Optional Properties

- `default` (any): Default value when parameter is not provided
- `description` (string): Human-readable parameter description
- `runtimeFallback` (string): Name of a state key to use as fallback if parameter not provided
- `enum` (array): Array of allowed values for validation
- `min` (number): Minimum value for numeric types
- `max` (number): Maximum value for numeric types
- `kind` (string): Additional metadata (e.g., `"implicit"` for parameters handled automatically)
- `transform` (object): Rules for transforming values for complex inputs

## Side Effects Properties

Commands can define side effects that modify the application state after successful execution:

- `setState` (object): Updates specific state keys with values from parameters or templates
- `clearState` (array): State keys to remove after execution
- `clearStateIf` (object): Conditionally removes state keys based on parameter values

## Example Command Manifest

### External Method Command

```json
{
	"name": "process",
	"commandType": "external-method",
	"modulePath": "yourDomain/index.js",
	"methodName": "yourMethod",
	"description": "Process data using your method",
	"syntax": "process(input, type, [options])",
	"parameters": [
		{
			"name": "input",
			"type": "string",
			"required": true,
			"description": "Input data to process",
			"runtimeFallback": "defaultFile"
		},
		{
			"name": "type",
			"type": "string",
			"required": true,
			"enum": ["typeA", "typeB", "typeC"],
			"description": "Processing type to use"
		}
	],
	"sideEffects": {
		"setState": {
			"lastProcessed": {
				"fromParam": "input",
				"template": "{{input | basename}}"
			}
		}
	},
	"examples": [
		"process(\"data.txt\", \"typeA\", option1=value1)",
		"process({input: \"input.txt\", type: \"typeB\", option1: \"value\"})"
	]
}
```

Note: The `modulePath` is resolved to an absolute path at contract loading time, eliminating the need for runtime path resolution during command execution.

### Internal Command

```json
{
	"name": "set",
	"commandType": "internal",
	"description": "Set a configuration value",
	"syntax": "set(key, value)",
	"parameters": [
		{
			"name": "key",
			"type": "string",
			"required": true,
			"description": "Configuration key to set"
		},
		{
			"name": "value",
			"type": "string",
			"required": true,
			"description": "Value to assign to the key"
		}
	],
	"sideEffects": {
		"setState": {
			"currentConfig": { "fromParam": "value" }
		}
	},
	"successOutput": "✅ Set {{key}} to {{value}}",
	"examples": ["set(\"theme\", \"dark\")"]
}
```

### Custom Command

```json
{
	"name": "complex",
	"commandType": "custom",
	"description": "A complex operation requiring custom logic",
	"syntax": "complex([options])",
	"parameters": [
		{
			"name": "verbose",
			"type": "boolean",
			"required": false,
			"default": false,
			"description": "Enable verbose output"
		}
	],
	"examples": ["complex()", "complex(verbose=true)"]
}
```

## Writing Your Own Manifest

To create a new command:

1. Create a new directory in `contract/[command-name]/`
2. Create a `manifest.json` file in this directory
3. Define the required properties (`name`, `commandType`, `description`, `parameters`)
4. Add optional properties as needed
5. If `commandType` is `"external-method"`, include `modulePath` and `methodName`
6. If `commandType` is `"custom"`, make sure to also create a `handler.js` file in the same directory

The kernel will automatically discover and integrate your command based on the manifest definition. Custom handlers are loaded on-demand by the CommandHandler component.


================================================================================

<!-- File: README.md -->

# 🧠 Vertex Kernel Framework

A domain-agnostic command processing engine that automatically discovers and executes commands defined in your domain-specific contract, with support for multiple transports and built-in command types.

## 🎯 Purpose

Vertex provides a universal command processing system that works with any domain. Simply define your commands in a contract folder and the kernel automatically discovers, validates, and executes them through multiple interfaces.

## 📁 Project Structure

```
your-project/
├── kernel/                    # Generic command engine (copy once) - "Vertex"
│   ├── utils/                 # Shared utilities
│   ├── contract.js            # Contract loading and management
│   ├── CommandHandler.js      # Core command processing
│   ├── CommandProcessor.js    # Command pipeline with state management
│   └── CommandParser.js       # Command parsing from user input
├── external-plugins/          # Configurable plugin directory (configurable via config.json)
│   ├── cli/                   # CLI interface
│   ├── repl/                  # REPL interface
│   ├── http/                  # HTTP server and API
│   ├── electron/              # Electron desktop application
│   └── generator/             # UI generation system
├── contract/                  # Your domain-specific commands
│   ├── global.json            # Domain configuration
│   └── [command-name]/        # Directory for each command
│       ├── manifest.json      # Command definition
│       ├── runtime.json       # Runtime behavior
│       ├── help.json          # User documentation
│       └── handler.js         # Custom command implementation (optional)
├── yourDomain/                # Domain-specific logic
├── generated-ui/              # Auto-generated web interface
└── main.js                    # Your project's entry point
```

Note: The contract loader (`kernel/contract.js`) focuses solely on manifest loading and caching, with module path resolution performed ahead-of-time to simplify command execution. The plugin system is fully configurable via `"pluginsDir"` in the kernel config.

## 🚀 Quick Start

### 1. Copy Vertex

Copy the entire `/kernel` directory to your project. This is the universal command engine - you never need to modify it.

### 2. Create Your Contract

Create a `/contract` directory with your domain-specific commands:

**contract/global.json**

```json
{
	"name": "your-app-name",
	"version": "1.0.0",
	"description": "Your application description",
	"prompt": "> ",
	"stateDefaults": {
		"currentUser": null,
		"currentProject": null
	}
}
```

**contract/yourcommand/manifest.json**

```json
{
	"name": "yourcommand",
	"commandType": "external-method",
	"modulePath": "yourDomain/index.js",
	"methodName": "yourDomainMethod",
	"description": "Description of what your command does",
	"syntax": "yourcommand(param1, [options])",
	"parameters": {
		"param1": {
			"type": "string",
			"required": true,
			"description": "Required parameter"
		}
	}
}
```

### 3. Configure Plugin Directory (Optional)

You can configure where plugins are loaded from in `kernel/config.json`:

```json
{
	"paths": {
		"pluginsDir": "external-plugins" // or "kernel/plugins", "/absolute/path", etc.
	}
}
```

### 4. Create Your Entry Point

Create a `main.js` file at your project root:

```javascript
#!/usr/bin/env node
import { launch } from './kernel/app.js';

// Launch with current directory as project root
const projectRoot = process.cwd();
launch(process.argv.slice(2), projectRoot);
```

The entry point delegates to Vertex, maintaining clean separation of concerns.

### 5. Run Your Application

```bash
# CLI mode
node main.js yourcommand param1=value1

# REPL mode
node main.js

# Generate web UI
node main.js --generate

# Serve web UI and API (uses --http which now serves both UI and API)
node main.js --http

# Launch Electron app
node main.js --electron
```

## 🧠 Command Types

Vertex supports three distinct command types with different handling strategies:

### 1. External-Method Commands (`commandType: "external-method"`)

Automatically handled by calling domain methods:

```json
{
	"name": "yourCommand",
	"commandType": "external-method",
	"modulePath": "yourDomain/index.js",
	"methodName": "yourMethod"
}
```

No handler file needed - the kernel automatically calls `yourDomain.yourMethod()`.

### 2. Internal Commands (`commandType: "internal"`)

Handled declaratively with template-based output:

```json
{
	"name": "use",
	"commandType": "internal",
	"successOutput": "✅ Using value: {{someParamValue}}",
	"parameters": {}
}
```

No handler file needed - behavior defined entirely in manifest.

### 3. Custom Commands (`commandType: "custom"`)

Require custom handler implementation:

```json
{
	"name": "randomize",
	"commandType": "custom"
}
```

Must provide `handler.js` with custom logic.

## 🔄 Transport System

Vertex provides multiple interfaces to access your commands:

### CLI Transport

Execute commands directly from the command line:

```bash
node main.js yourcommand param=value
```

### REPL Transport

Interactive shell with tab completion:

```bash
node main.js
> yourcommand param=value
```

### HTTP Transport

HTTP server serving both web UI and API:

```bash
# Start server with UI and API
node main.js --http

# Make API calls
GET http://localhost:8080?json={"name":"yourcommand","args":{"param":"value"}}
POST http://localhost:8080/api with JSON body

# UI available at: http://localhost:8080/
# API available at: http://localhost:8080/api
```

### Electron Transport

Desktop application with native UI. Uses dynamic kernel loading:

- `external-plugins/electron/electron-main.js` - Entry point that dynamically loads kernel modules
- `external-plugins/electron/KernelLoader.js` - Handles dynamic module loading at runtime

```bash
# Launch Electron app
node main.js --electron
```

## 🧩 How It Works

### Automatic Command Discovery

The kernel automatically scans your `/contract` directory and discovers all commands by reading their manifest files.

### Three-File Contract System

Commands are defined across three JSON files:

- `manifest.json` - Core kernel requirements (type, paths, params)
- `runtime.json` - Runtime behavior (defaults, validation, side effects)
- `help.json` - User documentation (descriptions, examples)

### Smart Command Routing

Based on `commandType` in manifests:

- **`external-method`**: Kernel automatically calls specified domain method with ahead-of-time path resolution
- **`internal`**: Kernel handles declaratively using manifest templates
- **`custom`**: Kernel delegates to custom `handler.js` implementation with on-demand loading

### Multiple Transports, Single Interface

All command types work seamlessly across all transports - write once, use everywhere.

### Zero Domain Coupling

The kernel contains zero domain-specific logic. All domain configuration and business logic lives in your `/contract` and `/yourDomain` folders.

## 🛠️ Advanced Features

### Configurable Plugin Directory

The plugin system supports configurable plugin directories:

- Set `"pluginsDir"` in `kernel/config.json`
- Can point to internal or external directories
- Uses path resolver for consistent path handling

### Dynamic Kernel Loading

The Electron plugin uses advanced dynamic loading:

- Kernel modules loaded dynamically based on runtime paths
- Two path arguments passed: `--project-root` and `--kernel-path`
- Maintains independence from hardcoded paths

### State Management

The kernel provides persistent state management:

```json
// In global.json
{
  "stateDefaults": {
    "currentUser": null,
    "currentProject": null,
    "lastResult": null
  }
}

// In command manifest
{
  "sideEffects": {
    "setState": {
      "currentProject": { "fromParam": "projectName" },
      "lastResult": { "template": "Processed {{fileName}}" }
    }
  }
}
```

### Runtime Fallbacks

Parameters can automatically fall back to state values:

```json
{
	"parameters": {
		"projectName": {
			"type": "string",
			"required": true,
			"runtimeFallback": "currentProject"
		}
	}
}
```

### Template Strings

Use template strings for dynamic values:

```json
{
	"sideEffects": {
		"setState": {
			"currentProject": { "fromParam": "projectName" },
			"projectFile": { "template": "{{projectName}}.json" }
		}
	}
}
```

## 🌐 Web UI Generation

The kernel automatically generates complete web interfaces from your contract manifests:

- Single-page application with dynamic forms
- Parameter-specific input fields
- Real-time API integration
- State management and fallbacks

Generate UI with: `node main.js --generate`

Just copy Vertex once and focus on writing your domain-specific commands!


================================================================================

// File: processor\CommandHandler.js

import { pathToFileURL } from 'url';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class CommandHandler {
	constructor(manifest, config = {}) {
		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('CommandHandler requires a manifest object');
		}

		// Validate config parameter
		if (typeof config !== 'object' || config === null) {
			throw new Error('CommandHandler requires a config object');
		}

		// Extract contractDir from paths in config
		if (!config.paths || !config.paths.contractDir) {
			throw new Error(
				'CommandHandler config requires paths.contractDir property',
			);
		}

		this.manifest = manifest;
		this.contractDir = config.paths.contractDir;
		// Initialize handler cache for custom command handlers
		this.handlerCache = new Map();
	}

	/**
	 * Handle a parsed command
	 * @param {Object} command - The command object
	 * @returns {Promise<Object>} - The result of the command
	 */
	async handleCommand(command) {
		if (!command) return;
		let result;
		try {
			// Get the command specification from the manifest
			const commandSpec = this.manifest.commands.find(
				(c) => c.name === command.name,
			);

			if (!commandSpec) {
				return {
					error: `Unknown command: ${command.name}`,
					output: null,
				};
			}

			// Handle internal commands declaratively when possible
			if (commandSpec.commandType === 'internal') {
				// Check if this is a fully declarative internal command
				if (commandSpec.successOutput) {
					// Handle declaratively without calling custom handler
					return this.handleInternalCommand(command, commandSpec);
				}
				// Fall back to custom handler for internal commands that need special logic
			}

			// Handle external-method commands - auto-handle directly without custom handler lookup
			if (commandSpec.commandType === 'external-method') {
				// Auto-handle external-method command if it has modulePath and methodName
				if (commandSpec.modulePath && commandSpec.methodName) {
					return await this.handleExternalMethod(command, commandSpec);
				} else {
					return {
						error: `External-method command '${command.name}' missing modulePath or methodName in manifest`,
						output: null,
					};
				}
			}

			// Handle custom commands - look for custom handler files
			const handlerFunction = await this.getHandler(command.name);

			if (handlerFunction && typeof handlerFunction === 'function') {
				// Call the handler function directly with the command arguments
				result = await handlerFunction(command.args);
			} else if (handlerFunction) {
				result = {
					error: `Handler for command '${command.name}' is not a function`,
					output: null,
				};
			} else {
				result = {
					error: `Unknown command: ${command.name}`,
					output: null,
				};
			}
			return result;
		} catch (error) {
			result = {
				error: `Error processing command: ${error.message}`,
				output: null,
			};
			return result;
		}
	}

	/**
	 * Handle a declarative internal command
	 * @param {Object} command - The parsed command object
	 * @param {Object} commandSpec - The command manifest specification
	 * @returns {Object} - The result of the command
	 */
	handleInternalCommand(command, commandSpec) {
		const { args = {} } = command;

		// Validate required parameters
		if (commandSpec.parameters) {
			for (const paramName in commandSpec.parameters) {
				const param = commandSpec.parameters[paramName];
				if (
					param.required &&
					(args[paramName] === undefined || args[paramName] === null)
				) {
					return {
						error: `Parameter '${paramName}' is required for command '${commandSpec.name}'`,
						output: null,
					};
				}
			}
		}

		// Generate success output from template if provided
		let output = null;
		if (commandSpec.successOutput) {
			output = this.renderTemplate(commandSpec.successOutput, args);
		}

		return {
			error: null,
			output: output,
		};
	}

	/**
	 * Handle an external-method command automatically
	 * @param {Object} command - The parsed command object
	 * @param {Object} commandSpec - The command manifest specification
	 * @returns {Promise<Object>} - The result of the command
	 */
	async handleExternalMethod(command, commandSpec) {
		const { args = {} } = command;

		try {
			// Use the pre-resolved absolute path from the manifest
			const resolvedModulePath =
				commandSpec.resolvedAbsolutePath || commandSpec.modulePath;

			// Convert to file URL for proper ES module loading
			const moduleUrl = pathToFileURL(resolvedModulePath).href;

			// Dynamically import the module
			const module = await import(moduleUrl);

			// Get the method from the module
			const method = module[commandSpec.methodName];

			if (typeof method !== 'function') {
				return {
					error: `Method '${commandSpec.methodName}' not found or is not a function in module '${resolvedModulePath}'`,
					output: null,
				};
			}

			// Call the method with the command arguments, wrap in try-catch to handle
			// plain return values and thrown errors - all domain functions should now
			// return plain values or throw errors directly
			try {
				const result = await method(args);
				// Treat the result as success output
				return {
					error: null,
					output: result,
				};
			} catch (methodError) {
				// If the method throws an error, convert it to the expected format
				return {
					error: methodError.message,
					output: null,
				};
			}
		} catch (error) {
			return {
				error: `Failed to execute external method '${commandSpec.methodName}' from '${resolvedModulePath}': ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Simple template renderer that substitutes {{paramName}} with parameter values
	 * @param {string} template - Template string with {{param}} placeholders
	 * @param {Object} params - Parameter values to substitute
	 * @returns {string} - Rendered template
	 */
	renderTemplate(template, params) {
		if (!template || typeof template !== 'string') {
			return '';
		}

		return template.replace(/\{\{([^}]+)\}\}/g, (match, paramName) => {
			const trimmedParamName = paramName.trim();
			if (params && params.hasOwnProperty(trimmedParamName)) {
				return String(params[trimmedParamName]);
			}
			return match; // Keep original placeholder if param not found
		});
	}

	/**
	 * Get or load a handler for a specific command
	 * @param {string} commandName - The command name to get handler for
	 * @returns {Function|null} - The handler function or null if not found
	 */
	async getHandler(commandName) {
		// Check if handler is already cached
		if (this.handlerCache.has(commandName)) {
			return this.handlerCache.get(commandName);
		}

		// Find the command in the manifest to locate its directory
		const commandSpec = this.manifest.commands.find(
			(c) => c.name === commandName,
		);
		if (!commandSpec) {
			console.warn(
				`Warning: Could not find command ${commandName} in manifest`,
			);
			return null;
		}

		try {
			// Build the handler file path using the stored contractDir
			const handlerPath = path.join(
				this.contractDir,
				commandName,
				'handler.js',
			);

			// Check if the handler file exists
			if (!fs.existsSync(handlerPath)) {
				console.warn(`Warning: Handler file not found at: ${handlerPath}`);
				return null;
			}

			// Convert to file URL for proper ES module loading
			const moduleUrl = pathToFileURL(handlerPath).href;

			// Dynamically import the handler module
			const handlerModule = await import(moduleUrl);

			let handlerFunction = null;

			// Check if it exports a default function (modern approach)
			if (
				handlerModule.default &&
				typeof handlerModule.default === 'function'
			) {
				handlerFunction = handlerModule.default;
			}
			// Check if it exports a class with a method (legacy approach for backward compatibility)
			else {
				for (const key of Object.keys(handlerModule)) {
					const HandlerClass = handlerModule[key];
					if (
						HandlerClass &&
						typeof HandlerClass === 'function' &&
						HandlerClass.name &&
						HandlerClass.name.endsWith('Handler')
					) {
						const handlerInstance = new HandlerClass();
						// Try to find the appropriate method name based on command name
						const methodName =
							'handle' +
							commandName.charAt(0).toUpperCase() +
							commandName
								.slice(1)
								.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase())
								.replace(/([A-Z])/g, (match, letter, index) =>
									index === 0 ? letter.toLowerCase() : letter,
								);

						if (typeof handlerInstance[methodName] === 'function') {
							// Create a wrapper function that calls the method
							handlerFunction = async (args) => {
								return await handlerInstance[methodName](args);
							};
							break;
						}
					}
				}
			}

			if (!handlerFunction) {
				console.warn(
					`Warning: Handler for ${commandName} does not export a default function or compatible class method`,
				);
				return null;
			}

			// Cache the handler for future use
			this.handlerCache.set(commandName, handlerFunction);
			return handlerFunction;
		} catch (error) {
			console.warn(
				`Warning: Could not load handler from ${commandName}/handler.js:`,
				error.message,
			);
			return null;
		}
	}
}


================================================================================

// File: processor\CommandParser.js

import { parseObjectStyle } from './parsers/Objective.js';
import { parseFunctionStyle } from './parsers/Functional.js';
/**
 * Command parser for REPL-style interface
 *
 * Supports both function-style and object-style syntax:
 * - command("param1", "param2", key=value)
 * - command({param1: "value1", key: value2})
 * - command param1 param2 key=value
 */
export class CommandParser {
	constructor(manifest) {
		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('CommandParser requires a manifest object');
		}

		this.manifest = manifest;
		this.patterns = {
			objectCall: /^(\w+)\s*\(\s*(\{.*\})\s*\)\s*$/,
			funcCall: /^(\w+)\s*\(\s*([^)]*)\s*\)\s*$/,
			simpleCommand: /^(\w+)\s*$/,
			cliStyle: /^(\w+)\s+(.+)$/,
		};
	}

	/**
	 * Parse a command string into a command object
	 * @param {string} input - The command string to parse
	 * @param {Object} context - Optional context with runtime state
	 * @returns {{error: string|null, command: Object|null}}
	 */
	parse(input, context = {}) {
		if (!input || typeof input !== 'string') {
			return {
				error: 'Invalid input: must be a non-empty string',
				command: null,
			};
		}

		const trimmed = input.trim();

		// First, try to parse as JSON command object
		try {
			const commandObj = JSON.parse(trimmed);
			if (commandObj && typeof commandObj === 'object' && commandObj.name) {
				// This is a valid JSON command object
				return {
					error: null,
					command: commandObj,
				};
			}
		} catch (jsonError) {
			// Not a JSON command object, continue with string parsing
		}

		// Try CLI-style parsing first
		const cliMatch = trimmed.match(this.patterns.cliStyle);
		if (cliMatch) {
			const spec = this.manifest.commands.find(
				(c) => c.name.toLowerCase() === cliMatch[1].toLowerCase(),
			);
			if (
				!(
					spec &&
					Object.entries(spec.parameters || {}).every(([_, p]) => !p.required)
				)
			) {
				return this.parseCliStyle(cliMatch[1], cliMatch[2], context);
			}
		}

		// Try object style first (backward compatible)
		const objectMatch = trimmed.match(this.patterns.objectCall);
		if (objectMatch) {
			return this.parseObjectStyle(objectMatch);
		}

		// Try function style
		const funcMatch = trimmed.match(this.patterns.funcCall);
		if (funcMatch) {
			return this.parseFunctionStyle(funcMatch);
		}

		// Try simple command
		const simpleMatch = trimmed.match(this.patterns.simpleCommand);
		if (simpleMatch) {
			const funcCall = `${trimmed}()`;
			const match = funcCall.match(this.patterns.funcCall);
			if (match) return this.parseFunctionStyle(match, context);
		}

		return {
			error: `Could not parse command: ${input}`,
			command: null,
		};
	}

	parseCliStyle(command, argsString, context = {}) {
		const spec = this.manifest.commands.find(
			(c) => c.name.toLowerCase() === command.toLowerCase(),
		);
		if (!spec) return { error: `Unknown command: ${command}`, command: null };

		const required = Object.entries(spec.parameters || {})
			.filter(([_, p]) => p.required)
			.map(([name, param]) => ({ name, ...param }));
		const parts = argsString.split(/\s+/).filter(Boolean);

		// Split into positional vs named pieces
		const positional = [];
		const named = [];

		for (const part of parts) {
			if (part.includes('=')) {
				named.push(part);
			} else {
				positional.push(part); // Remove JSON.stringify to avoid extra quotes
			}
		}

		// Map positional tokens to required parameters in order
		if (positional.length > required.length) {
			return {
				error: `Too many positional parameters for ${command}`,
				command: null,
			};
		}
		const positionalPairs = required
			.slice(0, positional.length)
			.map((p, i) => `${p.name}="${positional[i]}"`);

		// Build final function-style string
		const funcCall = `${command}(${[...positionalPairs, ...named].join(',')})`; // Remove space after comma
		const match = funcCall.match(this.patterns.funcCall);

		return this.parseFunctionStyle(match, context);
	}

	/**
	 * Parse a command in object style
	 * @param {string[]} - Destructured match from regex
	 * @param {Object} context - Optional context with runtime state
	 * @returns {{error: string|null, command: Object|null}}
	 */
	parseObjectStyle([, name, argsString], context = {}) {
		return parseObjectStyle([, name, argsString], context, this.manifest);
	}

	/**
	 * Parse a command in function style
	 * @param {string[]} - Destructured match from regex
	 * @param {Object} context - Optional context with runtime state
	 * @returns {{error: string|null, command: Object|null}}
	 */
	parseFunctionStyle([, name, argsString], context = {}) {
		return parseFunctionStyle([, name, argsString], context, this.manifest);
	}
}


================================================================================

// File: processor\CommandProcessor.js

import { CommandParser } from './CommandParser.js';
import { CommandHandler } from './CommandHandler.js';
import StateManager from './StateManager.js';

/**
 * Consolidates shared command processing logic across all transports
 */
export class CommandProcessor {
	constructor(config, manifest) {
		// Validate config parameter
		if (!config || typeof config !== 'object') {
			throw new Error('CommandProcessor requires a config object');
		}



		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('CommandProcessor requires a manifest object');
		}

		// Validate contractDir in config paths
		if (!config.paths.contractDir) {
			throw new Error(
				'CommandProcessor config requires paths.contractDir property',
			);
		}

		this.manifest = manifest;
		this.stateManager = new StateManager(manifest);
		this.parser = new CommandParser(manifest);
		// Pass the full config to CommandHandler
		this.handler = new CommandHandler(manifest, config); // Pass manifest and full config to CommandHandler
		this.state = this.stateManager.getStateMap();
	}

	/**
	 * Process a command through the complete pipeline
	 * @param {string} input - The command input string (can be JSON or string format)
	 * @param {string|null} contextFilePath - Path to context file for state management (default: null, uses default state)
	 * @param {boolean} formatToString - Whether to format the result to a string (default: true)
	 * @returns {Promise<Object>} - The result of command processing
	 */
	async processCommand(input, contextFilePath = null, formatToString = true) {
		try {
			const trimmedInput = input.trim().toLowerCase();

			// Handle special built-in commands before parsing
			if (
				trimmedInput === 'help' ||
				trimmedInput === 'help()' ||
				trimmedInput.startsWith('help(')
			) {
				// Create a help command object
				let args = {};
				if (
					trimmedInput.startsWith('help(') &&
					input.includes('(') &&
					input.includes(')')
				) {
					// Extract any specific command from help(command)
					const paramMatch = input.match(
						/help\\(\\s*["']?([^"')\\s]+)["']?\\s*\\)/i,
					);
					if (paramMatch && paramMatch[1]) {
						args = { command: paramMatch[1] };
					}
				}

				const context = {
					state: this.state,
					manifest: this.manifest,
				};

				const result = await this.handleHelpCommand(args, context);
				return result;
			}

			if (trimmedInput === 'exit' || trimmedInput === 'exit()') {
				const result = await this.handleExitCommand();
				// Exit command returns a special result for transports to handle
				return {
					output: 'Goodbye!',
					exit: true,
				};
			}

			// For all other commands, create context and parse normally
			const context = {
				state: this.state,
				manifest: this.manifest,
			};

			// Parse the command using the unified parser
			const { error, command } = this.parser.parse(input, context);

			if (error) {
				return { error, output: null };
			}

			// Execute the command through the handler
			const result = await this.handler.handleCommand(command);

			// Apply side effects and save state if command was successful and context file path is provided
			if (!result.error && contextFilePath !== null) {
				const commandSpec = this.manifest.commands.find(
					(c) => c.name === command.name,
				);
				if (commandSpec) {
					this.stateManager.applySideEffects(command, commandSpec);
					this.stateManager.saveState();
				}
			}
			return result;
		} catch (error) {
			return {
				error: `Command processing error: ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Handle the help command logic inline
	 * @param {Object} args - Arguments for the help command
	 * @param {Object} context - Execution context
	 * @returns {Object} - Result of the help command
	 */
	async handleHelpCommand(args, context) {
		const { manifest } = context;
		const { command: specificCommand } = args;

		if (specificCommand) {
			// Show help for specific command
			const cmd = manifest.commands.find((c) => c.name === specificCommand);
			if (!cmd) {
				return { error: `Unknown command: ${specificCommand}` };
			}

			return { output: this.formatCommandHelp(cmd) };
		} else {
			// Show general help
			return { output: this.formatGeneralHelp(manifest) };
		}
	}

	/**
	 * Format general help text
	 * @param {Object} manifest - The application manifest
	 * @returns {string} Formatted help text
	 */
	formatGeneralHelp(manifest) {
		let helpText = `🔗 ${manifest.name} - ${manifest.description}\n`;
		helpText += '='.repeat(Math.max(manifest.name.length + 2, 40)) + '\n\n';
		helpText += 'Available commands:\n';

		// Sort commands alphabetically
		const sortedCommands = [...manifest.commands].sort((a, b) =>
			a.name.localeCompare(b.name),
		);

		for (const cmd of sortedCommands) {
			helpText += `${cmd.name}${this.formatParamsSignature(cmd)} - ${cmd.description}\n`;
		}

		helpText += '\nhelp([command]) - Show help information\n';
		helpText += 'exit() - Exit the program\n';
		helpText += '\nCommand Syntax:\n';
		helpText += '• Function style: command(param1, param2, key=value)\n';
		helpText += '• Object style: command({param1: value, key: value})\n';
		helpText += '• Simple style: command\n';

		return helpText;
	}

	/**
	 * Format help for a specific command
	 * @param {Object} cmd - The command manifest
	 * @returns {string} Formatted command help
	 */
	formatCommandHelp(cmd) {
		let helpText = `🔗 ${cmd.name}${this.formatParamsSignature(cmd)}\n`;
		helpText += '   ' + cmd.description + '\n\n';

		const requiredParams = cmd.parameters
			? Object.entries(cmd.parameters)
					.filter(([_, p]) => p.required)
					.map(([name, param]) => ({ name, ...param }))
			: [];
		const optionalParams = cmd.parameters
			? Object.entries(cmd.parameters)
					.filter(([_, p]) => !p.required)
					.map(([name, param]) => ({ name, ...param }))
			: [];

		if (requiredParams.length > 0) {
			helpText += '   Required:\n';
			for (const param of requiredParams) {
				helpText += `       ${param.name} - ${param.description}\n`;
			}
			helpText += '\n';
		}

		if (optionalParams.length > 0) {
			helpText += '   Options (key=value):\n';
			for (const param of optionalParams) {
				const defaultValue =
					param.default !== undefined ? ` (default: ${param.default})` : '';
				const constraints = this.formatParamConstraints(param);
				const constraintText = constraints ? ` ${constraints}` : '';
				helpText += `       ${param.name}=${param.type}${defaultValue}${constraintText} - ${param.description}\n`;
			}
			helpText += '\n';
		}

		if (cmd.examples && cmd.examples.length > 0) {
			helpText += '   Examples:\n';
			for (const example of cmd.examples) {
				helpText += `       ${example}\n`;
			}
		}

		return helpText;
	}

	/**
	 * Format parameter signature for a command
	 * @param {Object} cmd - The command manifest
	 * @returns {string} Formatted parameter signature
	 */
	formatParamsSignature(cmd) {
		if (!cmd.parameters || Object.keys(cmd.parameters).length === 0) {
			return '()';
		}

		const required = Object.entries(cmd.parameters)
			.filter(([_, p]) => p.required)
			.map(([name, param]) => ({ name, ...param }));
		const optional = Object.entries(cmd.parameters)
			.filter(([_, p]) => !p.required)
			.map(([name, param]) => ({ name, ...param }));

		const requiredStr = required.map((p) => p.name).join(', ');
		const optionalStr = optional.map((p) => `[${p.name}]`).join(', ');

		let paramsStr = '';
		if (required.length > 0 && optional.length > 0) {
			paramsStr = `${requiredStr}, ${optionalStr}`;
		} else if (required.length > 0) {
			paramsStr = requiredStr;
		} else if (optional.length > 0) {
			paramsStr = optionalStr;
		}

		return `(${paramsStr})`;
	}

	/**
	 * Format parameter constraints for display
	 * @param {Object} param - The parameter manifest
	 * @returns {string} Formatted constraints
	 */
	formatParamConstraints(param) {
		const constraints = [];

		if (param.min !== undefined) {
			constraints.push(`min: ${param.min}`);
		}
		if (param.max !== undefined) {
			constraints.push(`max: ${param.max}`);
		}
		if (param.enum) {
			constraints.push(`one of: [${param.enum.join(', ')}]`);
		}

		return constraints.length > 0 ? `(${constraints.join(', ')})` : '';
	}

	/**
	 * Handle the exit command (no special logic needed, just return exit indication)
	 * @returns {Object} - Result of the exit command
	 */
	async handleExitCommand() {
		return {
			output: 'Goodbye!',
			exit: true,
		};
	}

	/**
	 * Process a command and apply side effects manually
	 * @param {Object} command - The parsed command object
	 * @param {string|null} contextFilePath - Path to context file for state management (default: null, uses default state)
	 * @param {boolean} formatToString - Whether to format the result to a string (default: true)
	 * @returns {Promise<Object>} - The result of command processing
	 */
	async processParsedCommand(
		command,
		contextFilePath = null,
		formatToString = true,
	) {
		try {
			// Execute the command through the handler
			const result = await this.handler.handleCommand(command);

			// Apply side effects and save state if command was successful and context file path is provided
			if (!result.error && contextFilePath !== null) {
				const commandSpec = this.manifest.commands.find(
					(c) => c.name === command.name,
				);
				if (commandSpec) {
					this.stateManager.applySideEffects(command, commandSpec);
					this.stateManager.saveState();
				}
			}

			// Optionally format the result to a string if requested

			return result;
		} catch (error) {
			return {
				error: `Command processing error: ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Get the current state
	 * @returns {Map} - The current state map
	 */
	getState() {
		return this.state;
	}

	/**
	 * Get the manifest
	 * @returns {Object} - The application manifest
	 */
	getManifest() {
		return this.manifest;
	}

	/**
	 * Get the parser instance
	 * @returns {CommandParser} - The command parser
	 */
	getParser() {
		return this.parser;
	}

	/**
	 * Get the handler instance
	 * @returns {CommandHandler} - The command handler
	 */
	getHandler() {
		return this.handler;
	}
}


================================================================================

// File: processor\StateManager.js

import fs from 'fs';
import path from 'path';

/**
 * Manages persistent state for the application
 */
export class StateManager {
	constructor(manifest) {
		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('StateManager requires a manifest object');
		}

		this.manifest = manifest;
		this.state = new Map(Object.entries(this.manifest.stateDefaults || {}));
		// Don't load state in constructor, only when provided
	}

	/**
	 * Load state from persistent storage
	 */
	loadState(contextFilePath = null) {
		try {
			if (contextFilePath && fs.existsSync(contextFilePath)) {
				const stateData = fs.readFileSync(contextFilePath, 'utf8');
				const savedState = JSON.parse(stateData);
				if (savedState && typeof savedState === 'object') {
					// Load only valid state keys from manifest defaults
					const defaultState = this.manifest.stateDefaults || {};
					for (const [key, defaultValue] of Object.entries(defaultState)) {
						if (key in savedState) {
							this.state.set(key, savedState[key]);
						} else {
							// Ensure defaults are present
							this.state.set(key, defaultValue);
						}
					}
				}
			}
		} catch (error) {
			console.warn(
				'⚠️ Could not load persistent state, using defaults:',
				error.message,
			);
			// Initialize with manifest defaults
			const defaultState = this.manifest.stateDefaults || {};
			for (const [key, value] of Object.entries(defaultState)) {
				this.state.set(key, value);
			}
		}
	}

	/**
	 * Save state to persistent storage
	 */
	saveState(contextFilePath = null) {
		if (!contextFilePath) return; // Don't save if no file path provided
		try {
			// Ensure context directory exists
			const contextDir = path.dirname(contextFilePath);
			if (!fs.existsSync(contextDir)) {
				fs.mkdirSync(contextDir, { recursive: true });
			}

			// Create serializable state object with only the default state keys
			const defaultState = this.manifest.stateDefaults || {};
			const stateToSave = {};

			for (const [key] of Object.entries(defaultState)) {
				if (this.state.has(key)) {
					stateToSave[key] = this.state.get(key);
				}
			}

			fs.writeFileSync(
				contextFilePath,
				JSON.stringify(stateToSave, null, 2),
			);
		} catch (error) {
			console.warn('⚠️ Could not save persistent state:', error.message);
		}
	}

	/**
	 * Get value from state
	 * @param {string} key - State key
	 * @returns {*} Value or undefined if not set
	 */
	get(key) {
		return this.state.get(key);
	}

	/**
	 * Set value in state
	 * @param {string} key - State key
	 * @param {*} value - Value to set
	 */
	set(key, value) {
		this.state.set(key, value);
	}

	/**
	 * Check if key exists in state
	 * @param {string} key - State key
	 * @returns {boolean} True if key exists
	 */
	has(key) {
		return this.state.has(key);
	}

	/**
	 * Delete key from state
	 * @param {string} key - State key to delete
	 */
	delete(key) {
		return this.state.delete(key);
	}

	/**
	 * Get the entire state as a Map
	 * @returns {Map} Current state
	 */
	getStateMap() {
		return this.state;
	}

	/**
	 * Apply side effects to state based on command manifest
	 * @param {Object} command - Command object
	 * @param {Object} commandManifest - Manifest for the executed command
	 */
	applySideEffects(command, commandManifest) {
		if (!commandManifest?.sideEffects) return;

		if (commandManifest.sideEffects.setState) {
			for (const [key, rule] of Object.entries(
				commandManifest.sideEffects.setState,
			)) {
				let value;

				if (rule.fromParam && command.args) {
					value = command.args[rule.fromParam];
				}
				if (value === undefined && rule.template && command.args) {
					// Apply template string with available parameters
					value = this.evaluateTemplate(rule.template, command.args);
				}

				if (value !== undefined) {
					this.state.set(key, value);
				}
			}
		}

		if (commandManifest.sideEffects.clearState) {
			for (const key of commandManifest.sideEffects.clearState) {
				this.state.delete(key);
			}
		}

		if (commandManifest.sideEffects.clearStateIf) {
			for (const [key, rule] of Object.entries(
				commandManifest.sideEffects.clearStateIf,
			)) {
				if (
					rule.fromParam &&
					command.args &&
					command.args[rule.fromParam] !== undefined
				) {
					const paramValue = command.args[rule.fromParam];
					const stateValue = this.state.get(key);

					// Clear state if the parameter value matches the current state value
					if (paramValue === stateValue) {
						this.state.delete(key);
					}
				}
			}
		}
	}

	/**
	 * Helper to evaluate template strings
	 * @private
	 */
	evaluateTemplate(template, bag) {
		return template.replace(
			/\{\{(\w+)(?:\s*\|\s*(\w+))?\}\}/g,
			(_, key, filter) => {
				let val = bag[key];
				if (val === undefined) return '';

				if (filter === 'basename') {
					val = String(val).replace(/\.[^/.]+$/, '');
				}

				return String(val);
			},
		);
	}
}

// Export the class, but not the singleton since it now requires a paths parameter
export default StateManager;


================================================================================

// File: processor\parsers\Functional.js

import { ParserUtils } from './Utils.js';

/**
 * Parse a command in function style
 * @param {string[]} match - Destructured match from regex
 * @param {Object} context - Optional context with runtime state
 * @param {Object} manifest - The application manifest
 * @returns {{error: string|null, command: Object|null}}
 */
export function parseFunctionStyle(
	[, name, argsString],
	context = {},
	manifest,
) {
	const commandName = name.toLowerCase();

	// Find the command in manifest
	const command = manifest.commands.find(
		(cmd) => cmd.name.toLowerCase() === commandName,
	);
	if (!command) {
		return {
			error: `Unknown command: ${name}`,
			command: null,
		};
	}

	const parameters = command.parameters || {};
	const requiredParams = Object.entries(parameters)
		.filter(([_, p]) => p.required)
		.map(([name, param]) => ({ name, ...param }));
	const optionalParams = Object.entries(parameters)
		.filter(([_, p]) => !p.required)
		.map(([name, param]) => ({ name, ...param }));

	let args = {};
	const argPairs = argsString
		.split(',')
		.map((s) => s.trim())
		.filter(Boolean);

	let positionalIndex = 0;

	// Process arguments
	for (const argPair of argPairs) {
		if (argPair.includes('=')) {
			// Named parameter: key=value
			const [key, valueStr] = argPair.split('=', 2).map((s) => s.trim());
			if (!key || !valueStr) {
				return {
					error: `Invalid named parameter: ${argPair}`,
					command: null,
				};
			}

			// Validate parameter exists
			const paramName = Object.keys(parameters).find(
				(p) => p.toLowerCase() === key.toLowerCase(),
			);
			if (!paramName) {
				return {
					error: `Unknown parameter: ${key}`,
					command: null,
				};
			}

			const param = parameters[paramName];
			args[paramName] = ParserUtils.normalizeValue(valueStr);
		} else {
			// Positional parameter
			if (positionalIndex >= requiredParams.length) {
				return {
					error: `Unexpected positional parameter: ${argPair}. All required parameters already provided.`,
					command: null,
				};
			}

			const param = requiredParams[positionalIndex];
			args[param.name] = ParserUtils.normalizeValue(argPair);
			positionalIndex++;
		}
	}

	// Check for missing required parameters after applying runtime fallbacks
	const missingParams = [];
	for (const param of requiredParams) {
		if (!(param.name in args)) {
			// Try to apply runtime fallback
			if (
				param.runtimeFallback &&
				context &&
				context.state &&
				context.state.has(param.runtimeFallback)
			) {
				args[param.name] = context.state.get(param.runtimeFallback);
			} else {
				missingParams.push(param.name);
			}
		}
	}

	if (missingParams.length > 0) {
		return {
			error: `Missing required parameters: ${missingParams.join(',')}`,
			command: null,
		};
	}

	// Apply defaults
	for (const param of optionalParams) {
		if (!(param.name in args) && param.default !== undefined) {
			args[param.name] = param.default;
		}
	}

	// Validate arguments against manifest specs
	for (const paramName in parameters) {
		const param = parameters[paramName];
		const value = args[paramName];
		if (value === undefined && !param.required) continue;

		// Type validation for union types
		const types = param.type.split('|').map((t) => t.trim());
		let parsedValue = value;
		let typeValidationPassed = false;

		// Try each type in the union until one succeeds
		for (const type of types) {
			try {
				if (type === 'integer') {
					const intValue = parseInt(value, 10);
					if (!isNaN(intValue)) {
						parsedValue = intValue;
						typeValidationPassed = true;
						break;
					}
				} else if (type === 'number') {
					const numValue = parseFloat(value);
					if (!isNaN(numValue)) {
						parsedValue = numValue;
						typeValidationPassed = true;
						break;
					}
				} else if (type === 'boolean') {
					if (typeof value === 'boolean') {
						parsedValue = value;
						typeValidationPassed = true;
						break;
					} else {
						const lowerValue = value.toLowerCase();
						if (lowerValue === 'true') {
							parsedValue = true;
							typeValidationPassed = true;
							break;
						} else if (lowerValue === 'false') {
							parsedValue = false;
							typeValidationPassed = true;
							break;
						}
					}
				} else if (type === 'array') {
					if (Array.isArray(value)) {
						parsedValue = value;
						typeValidationPassed = true;
						break;
					} else {
						try {
							const arrayValue = JSON.parse(value);
							if (Array.isArray(arrayValue)) {
								parsedValue = arrayValue;
								typeValidationPassed = true;
								break;
							}
						} catch {
							// Continue to next type
						}
					}
				} else if (type === 'string') {
					// Strings are always valid (everything can be treated as a string)
					parsedValue = String(value);
					typeValidationPassed = true;
					break;
				}
			} catch {
				// Continue to next type if this one fails
				continue;
			}
		}

		// If no type validation passed, return error
		if (!typeValidationPassed) {
			return {
				error: `Parameter ${paramName} must be of type: ${param.type}`,
				command: null,
			};
		}

		// Update args with parsed value
		args[paramName] = parsedValue;

		// Range validation for numbers
		if (types.includes('integer') || types.includes('number')) {
			if (param.min !== undefined && parsedValue < param.min) {
				return {
					error: `Parameter ${paramName} must be at least ${param.min}`,
					command: null,
				};
			}
			if (param.max !== undefined && parsedValue > param.max) {
				return {
					error: `Parameter ${paramName} must be at most ${param.max}`,
					command: null,
				};
			}
		}

		// Enum validation
		if (param.enum && !param.enum.includes(parsedValue)) {
			return {
				error: `Parameter ${paramName} must be one of: ${param.enum.join(', ')}`,
				command: null,
			};
		}
	}

	return {
		error: null,
		command: {
			name: command.name,
			args,
		},
	};
}


================================================================================

// File: processor\parsers\Objective.js

import { ParserUtils } from './Utils.js';

/**
 * Parse a command in object style
 * @param {string[]} match - Destructured match from regex
 * @param {Object} context - Optional context with runtime state
 * @param {Object} manifest - The application manifest
 * @returns {{error: string|null, command: Object|null}}
 */
export function parseObjectStyle([, name, argsString], context = {}, manifest) {
	const commandName = name.toLowerCase();

	// Find the command in manifest
	const command = manifest.commands.find(
		(cmd) => cmd.name.toLowerCase() === commandName,
	);
	if (!command) {
		return {
			error: `Unknown command: ${name}`,
			command: null,
		};
	}

	const parameters = command.parameters || {};
	const requiredParams = Object.entries(parameters)
		.filter(([_, p]) => p.required)
		.map(([name, param]) => ({ name, ...param }));
	const optionalParams = Object.entries(parameters)
		.filter(([_, p]) => !p.required)
		.map(([name, param]) => ({ name, ...param }));

	let args;
	try {
		// Try parsing as JSON
		args = JSON.parse(argsString);
	} catch (e) {
		try {
			// Fallback: Convert JS object literal to JSON (add quotes around keys)
			const wrappedArgsString = argsString.replace(
				/([{,]\s*)([a-zA-Z_$][\w$]*)(\s*:)/g,
				'$1"$2"$3',
			);
			args = JSON.parse(wrappedArgsString);
		} catch (fallbackError) {
			return {
				error: `Invalid object syntax: ${argsString}`,
				command: null,
			};
		}
	}

	// Handle non-object inputs for parameters with transform rules
	if (typeof args !== 'object' || args === null) {
		const paramEntries = Object.entries(parameters);
		const singleParamEntry = paramEntries.find(
			([_, p]) => p.required && p.transform,
		);
		if (singleParamEntry) {
			const [paramName, singleParam] = singleParamEntry;
			const types = singleParam.type.split('|').map((t) => t.trim());
			let parsedValue = args;

			// Validate and parse type
			if (types.includes('integer') && !isNaN(parseInt(args, 10))) {
				parsedValue = parseInt(args, 10);
			} else if (types.includes('string')) {
				parsedValue = String(args);
			} else {
				return {
					error: `Parameter ${paramName} must be ${singleParam.type}`,
					command: null,
				};
			}

			// Apply transform rule from manifest
			if (singleParam.transform) {
				const isInteger =
					types.includes('integer') && Number.isInteger(parsedValue);
				args = isInteger
					? singleParam.transform.then
					: singleParam.transform.else;
				args[
					singleParam.transform.then.id || singleParam.transform.else.title
				] = parsedValue;
			} else {
				args = { [paramName]: parsedValue };
			}
		} else {
			return {
				error: `Expected object or single value for ${commandName} with transform`,
				command: null,
			};
		}
	}

	// Normalize arguments
	args = ParserUtils.normalizeArgs(args);

	// Validate parameters against manifest
	const validatedArgs = {};

	// Check for unknown parameters
	for (const key of Object.keys(args)) {
		const paramName = Object.keys(parameters).find(
			(p) => p.toLowerCase() === key.toLowerCase(),
		);
		if (!paramName) {
			return {
				error: `Unknown parameter: ${key}`,
				command: null,
			};
		}
	}

	// Validate and process each parameter
	for (const paramName in parameters) {
		const param = parameters[paramName];

		// Get current value, applying fallback if needed
		let value = args[paramName];
		if (
			value === undefined &&
			param.runtimeFallback &&
			context &&
			context.state &&
			context.state.has(param.runtimeFallback)
		) {
			value = context.state.get(param.runtimeFallback);
			args[paramName] = value; // Update args with fallback value
		}

		// Check for missing required parameters
		if (value === undefined && param.required) {
			return {
				error: `Missing required parameter: ${paramName}`,
				command: null,
			};
		}

		// Apply default for optional parameters
		if (value === undefined && !param.required && param.default !== undefined) {
			validatedArgs[paramName] = param.default;
			continue;
		}

		if (value === undefined) continue;

		// Type validation
		const types = param.type.split('|').map((t) => t.trim());
		let parsedValue = value;

		if (types.includes('integer')) {
			parsedValue = parseInt(value, 10);
			if (isNaN(parsedValue)) {
				return {
					error: `Parameter ${paramName} must be an integer`,
					command: null,
				};
			}
		} else if (types.includes('number')) {
			parsedValue = parseFloat(value);
			if (isNaN(parsedValue)) {
				return {
					error: `Parameter ${paramName} must be a number`,
					command: null,
				};
			}
		} else if (types.includes('boolean')) {
			if (typeof value !== 'boolean') {
				const lowerValue = String(value).toLowerCase();
				if (lowerValue === 'true') parsedValue = true;
				else if (lowerValue === 'false') parsedValue = false;
				else
					return {
						error: `Parameter ${paramName} must be a boolean (true/false)`,
						command: null,
					};
			}
		} else if (types.includes('array')) {
			if (!Array.isArray(value)) {
				try {
					parsedValue = JSON.parse(value);
					if (!Array.isArray(parsedValue)) throw new Error();
				} catch {
					return {
						error: `Parameter ${paramName} must be an array`,
						command: null,
					};
				}
			}
		} else if (types.includes('string')) {
			parsedValue = String(value);
		} else {
			return {
				error: `Unsupported type for ${paramName}: ${param.type}`,
				command: null,
			};
		}

		// Range validation for numbers
		if (types.includes('integer') || types.includes('number')) {
			if (param.min !== undefined && parsedValue < param.min) {
				return {
					error: `Parameter ${paramName} must be at least ${param.min}`,
					command: null,
				};
			}
			if (param.max !== undefined && parsedValue > param.max) {
				return {
					error: `Parameter ${paramName} must be at most ${param.max}`,
					command: null,
				};
			}
		}

		// Enum validation
		if (param.enum && !param.enum.includes(parsedValue)) {
			return {
				error: `Parameter ${paramName} must be one of: ${param.enum.join(', ')}`,
				command: null,
			};
		}

		validatedArgs[paramName] = parsedValue;
	}

	return {
		error: null,
		command: {
			name: command.name,
			args: validatedArgs,
		},
	};
}


================================================================================

// File: processor\parsers\Utils.js

export class ParserUtils {
	/**
	 * Normalize a single value
	 */
	static normalizeValue(value) {
		let result = value;

		if (typeof value === 'string') {
			const trimmed = value.trim();
			let unquoted = trimmed;

			if (
				(trimmed.startsWith('"') && trimmed.endsWith('"')) ||
				(trimmed.startsWith("'") && trimmed.endsWith("'"))
			) {
				unquoted = trimmed.slice(1, -1);
			}

			if (/^-?\d+$/.test(unquoted)) {
				result = parseInt(unquoted, 10);
			} else if (/^-?\d+\.\d+$/.test(unquoted)) {
				result = parseFloat(unquoted);
			} else if (unquoted === 'true') {
				result = true;
			} else if (unquoted === 'false') {
				result = false;
			} else if (unquoted !== trimmed) {
				result = unquoted;
			}
		}

		return result;
	}

	/**
	 * Split key=value pairs with quote handling
	 */
	static splitKeyValue(pair) {
		if (!pair.includes('=')) return [null, null];

		const eqIndex = pair.indexOf('=');
		const key = pair.slice(0, eqIndex).trim();
		const value = this.normalizeValue(pair.slice(eqIndex + 1).trim());

		return [key, value];
	}

	/**
	 * Normalize all values in an args object
	 */
	static normalizeArgs(args) {
		const result = {};
		for (const [key, value] of Object.entries(args)) {
			result[key] = this.normalizeValue(value);
		}
		return result;
	}

	/**
	 * Validate command has required positional arguments
	 */
	static validatePositionalArgs(args, requiredCount) {
		if (args.length < requiredCount) {
			throw new Error(`Requires at least ${requiredCount} arguments`);
		}
		for (let i = 0; i < requiredCount; i++) {
			if (args[i].includes('=')) {
				throw new Error(`Argument ${i + 1} must be positional`);
			}
		}
	}

	static isNullish(v) {
		return v === null || v === undefined || v === 'null';
	}
}


================================================================================

// File: utils\config-loader.js

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import pathResolver from './path-resolver.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Load configuration from file with fallback to defaults
 * @param {string} configFilePath - Path to configuration file
 * @param {Object} defaultConfig - Default configuration values
 * @returns {Object} Loaded configuration merged with defaults
 */
function loadConfigFromFile(configFilePath, defaultConfig = {}) {
	let config = { ...defaultConfig };
	try {
		if (fs.existsSync(configFilePath)) {
			const configFile = fs.readFileSync(configFilePath, 'utf8');
			const loadedConfig = JSON.parse(configFile);
			config = { ...config, ...loadedConfig };
		}
	} catch (error) {
		console.warn(
			'⚠️ Could not load config file, using defaults:',
			error.message,
		);
	}
	return config;
}

/**
 * Build a complete configuration object with both file config and kernel-calculated paths
 * @param {string} projectRoot - The project root directory
 * @returns {Object} Complete configuration with resolved paths
 */
export function buildConfig(projectRoot) {
	const configFilePath = path.join(projectRoot, 'kernel', 'config.json');

	// Load kernel configuration from file
	const kernelConfig = loadConfigFromFile(configFilePath, {
		paths: {
			kernelDir: 'kernel',
			contractDir: 'contract',
			configDir: 'config',
			contextDir: 'context',
		}
	});

	// Load configuration for each enabled plugin and merge their paths
	const allPluginPaths = {};
	if (kernelConfig.plugins) {
		for (const [pluginName, pluginConfig] of Object.entries(
			kernelConfig.plugins,
		)) {
			if (pluginConfig.enabled) {
				// Load plugin-specific config
				const pluginConfigPath = path.join(
					projectRoot,
					'kernel',
					'plugins',
					pluginName,
					'config.json',
				);
				if (fs.existsSync(pluginConfigPath)) {
					try {
						const pluginFileConfig = JSON.parse(
							fs.readFileSync(pluginConfigPath, 'utf8'),
						);
						// If the plugin has specific paths, merge them
						if (pluginFileConfig.paths) {
							Object.assign(allPluginPaths, pluginFileConfig.paths);
						}
					} catch (error) {
						console.warn(
							`⚠️ Could not load config for plugin ${pluginName}:`,
							error.message,
						);
					}
				}
			}
		}
	}

	// Build complete paths using path resolver and kernel config
	const resolvedPaths = {
		// Core paths that must be calculated by kernel
		configFilePath: configFilePath,
		contextFilePath: pathResolver.getContextFilePath('state.json'),
		replHistoryFilePath: pathResolver.getContextFilePath('repl-history.json'),
		contractDir: pathResolver.getContractDir(),
		servedUIDir: pathResolver.getServedUIDir(),
		electronPreloadPath: pathResolver.getElectronPreloadPath(),

		// Use kernel config paths with kernel fallbacks
		kernelDir: pathResolver.getKernelDir(),
		generatedUIDir: pathResolver.getGeneratedUIDir(),
		contextDir: pathResolver.getContextDir(),
		templatesDir: pathResolver.getTemplatesDir(),
		uiFilePath: pathResolver.getUIFilePath(),
	};

	// Combine all paths in the right order for overrides:
	// 1. Plugin paths (defaults)
	// 2. Kernel config paths (overrides plugin defaults)
	// 3. Resolved paths (kernel-calculated, can be overridden by kernel config)
	const combinedPaths = {
		...allPluginPaths, // Plugin defaults first
		...kernelConfig.paths, // Kernel config overrides take precedence
		...resolvedPaths, // Resolved paths come after kernel config but can be overridden
	};

	// Build and return complete config object
	return {
		...kernelConfig,
		paths: combinedPaths,
	};
}


================================================================================

// File: utils\path-resolver.js

import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

/**
 * Centralized path resolver for the entire kernel
 * Provides consistent path resolution across all kernel modules
 * Focuses on kernel-specific and project structure paths only
 */
class KernelPathResolver {
	constructor() {
		// Determine the project root dynamically
		// This file is at kernel/utils/path-resolver.js
		const currentFileDir = path.dirname(fileURLToPath(import.meta.url)); // kernel/utils/
		this.projectRoot = path.join(currentFileDir, '..'); // Go up 1 level to kernel/
		this.projectRoot = path.join(this.projectRoot, '..'); // Go up 1 more level to project root

		// Load configuration for path overrides
		this.config = this.loadConfig();
	}

	/**
	 * Load configuration for path overrides
	 * @returns {Object} Configuration object with path overrides
	 */
	loadConfig() {
		// Use the hardcoded default config path to avoid circular dependency
		const hardcodedConfigPath = path.join(
			this.projectRoot,
			'kernel',
			'config.json',
		);
		try {
			if (fs.existsSync(hardcodedConfigPath)) {
				const configFile = fs.readFileSync(hardcodedConfigPath, 'utf8');
				const loadedConfig = JSON.parse(configFile);
				return loadedConfig;
			}
		} catch (error) {
			console.warn(
				'⚠️ Could not load config file for path overrides, using defaults:',
				error.message,
			);
		}
		// Return empty config if loading fails
		return {};
	}

	/**
	 * Get the project root directory
	 * @returns {string} The project root path
	 */
	getProjectRoot() {
		return this.projectRoot;
	}

	/**
	 * Get the path to the kernel directory
	 * @returns {string} Path to kernel directory
	 */
	getKernelDir() {
		const configPath = this.config.paths?.kernelDir || 'kernel';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to the contract directory
	 * @returns {string} Path to contract directory
	 */
	getContractDir() {
		const configPath = this.config.paths?.contractDir || 'contract';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to the generated UI directory
	 * @returns {string} Path to generated UI directory
	 */
	getGeneratedUIDir() {
		const configPath = this.config.paths?.generatedUIDir || 'generated-ui';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to the served UI directory (for HTTP serving/Electron)
	 * @returns {string} Path to served UI directory
	 */
	getServedUIDir() {
		// For now, use the same directory as generated UI
		// This can be customized later to point to a different location
		const configPath =
			this.config.paths?.servedUIDir ||
			this.config.paths?.generatedUIDir ||
			'generated-ui';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to a specific UI file
	 * @param {string} filename - The UI filename (default: 'index.html')
	 * @returns {string} Path to the UI file
	 */
	getUIFilePath(filename = 'index.html') {
		return path.join(this.getGeneratedUIDir(), filename);
	}

	/**
	 * Get the path to the electron preload script
	 * @returns {string} Path to electron preload script
	 */
	getElectronPreloadPath() {
		const configPath =
			this.config.paths?.electronPreloadPath || 'electron-preload.js';
		// Always return absolute path for Electron preload
		return path.resolve(this.projectRoot, configPath);
	}

	/**
	 * Get the path to a specific contract manifest
	 * @returns {string} Path to the command's manifest
	 */
	getContractManifestPath(commandName) {
		return path.join(this.getContractDir(), commandName, 'manifest.json');
	}

	/**
	 * Get the path to a specific contract handler
	 * @returns {string} Path to the command's handler
	 */
	getContractHandlerPath(commandName) {
		return path.join(this.getContractDir(), commandName, 'handler.js');
	}

	/**
	 * Get the path to the config directory
	 * @returns {string} Path to config directory
	 */
	getConfigDir() {
		const configPath = this.config.paths?.configDir || 'config';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to a specific config file
	 * @param {string} filename - The config filename (default: 'config.json' for kernel config)
	 * @returns {string} Path to the config file
	 */
	getConfigFilePath(filename = 'config.json') {
		// For kernel config, always use the kernel directory
		return path.join(this.projectRoot, 'kernel', filename);
	}

	/**
	 * Get the path to the context directory
	 * @returns {string} Path to context directory
	 */
	getContextDir() {
		const configPath = this.config.paths?.contextDir || 'context';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to a specific context file
	 * @param {string} filename - The context filename
	 * @returns {string} Path to the context file
	 */
	getContextFilePath(filename) {
		return path.join(this.getContextDir(), filename);
	}

	/**
	 * Get the path to the templates directory
	 * @returns {string} Path to templates directory
	 */
	getTemplatesDir() {
		const configPath = this.config.paths?.templatesDir || 'templates';
		return path.join(this.projectRoot, configPath);
	}

	/**
	 * Get the path to a specific template file
	 * @param {string} filename - The template filename
	 * @returns {string} Path to the template file
	 */
	getTemplatePath(filename) {
		return path.join(this.getTemplatesDir(), filename);
	}

	/**
	 * Get an object containing all available paths
	 * @returns {Object} Object with all path values
	 */
	getAllPaths() {
		return {
			projectRoot: this.getProjectRoot(),
			kernelDir: this.getKernelDir(),
			contractDir: this.getContractDir(),
			generatedUIDir: this.getGeneratedUIDir(),
			servedUIDir: this.getServedUIDir(),
			electronPreloadPath: this.getElectronPreloadPath(),
			configDir: this.getConfigDir(),
			contextDir: this.getContextDir(),
			templatesDir: this.getTemplatesDir(),
			// Include some example paths with common filenames
			configFilePath: this.getConfigFilePath(),
			uiFilePath: this.getUIFilePath(),
			templatesDirPath: this.getTemplatesDir(),
		};
	}

	/**
	 * Get the path to the plugins directory
	 * @returns {string} Path to plugins directory
	 */
	getPluginsDir() {
		const configPath = this.config.paths?.pluginsDir || 'kernel/plugins';
		// If it's an absolute path, return as-is; otherwise resolve relative to project root
		if (path.isAbsolute(configPath)) {
			return configPath;
		}
		return path.join(this.projectRoot, configPath);
	}
}

// Create a singleton instance
const pathResolver = new KernelPathResolver();

// Export individual path functions for direct import
export const projectRoot = pathResolver.getProjectRoot();
export const kernelDir = pathResolver.getKernelDir();
export const contractDir = pathResolver.getContractDir();
export const generatedUIDir = pathResolver.getGeneratedUIDir();
export const servedUIDir = pathResolver.getServedUIDir();
export const electronPreloadPath = pathResolver.getElectronPreloadPath();
export const contextDir = pathResolver.getContextDir();
export const templatesDir = pathResolver.getTemplatesDir();

// Export the resolver instance for when more complex path operations are needed
export default pathResolver;


================================================================================

// File: utils\PluginLoader.js

import fs from 'fs';
import path from 'path';
import { pathToFileURL } from 'url';
import pathResolver from './path-resolver.js';

/**
 * PluginLoader - A dynamic plugin loader with caching capabilities
 * Similar to handler loading but for transport plugins like stdio, http, electron
 */
export class PluginLoader {
	constructor() {
		this.pluginCache = new Map(); // Cache plugins after loading
		this.pluginsBaseDir = pathResolver.getPluginsDir(); // Use path resolver to get plugins directory
	}

	/**
	 * Get or load a plugin by name
	 * @param {string} pluginName - Name of the plugin to load (e.g., 'stdio', 'http', 'electron')
	 * @returns {Object|null} - The loaded plugin module or null if not found
	 */
	async getPlugin(pluginName) {
		// Check if plugin is already cached
		if (this.pluginCache.has(pluginName)) {
			return this.pluginCache.get(pluginName);
		}

		try {
			// Build the plugin file path
			const pluginPath = path.join(this.pluginsBaseDir, pluginName, 'index.js');

			// Check if the plugin file exists
			if (!fs.existsSync(pluginPath)) {
				console.warn(`Warning: Plugin not found at: ${pluginPath}`);
				return null;
			}

			// Convert to file URL for proper ES module loading
			const moduleUrl = pathToFileURL(pluginPath).href;

			// Dynamically import the plugin module
			const pluginModule = await import(moduleUrl);

			// Cache the plugin for future use
			this.pluginCache.set(pluginName, pluginModule);
			return pluginModule;
		} catch (error) {
			console.warn(
				`Warning: Could not load plugin ${pluginName}:`,
				error.message,
			);
			return null;
		}
	}

	/**
	 * Load and return a specific plugin method (start, run, etc.)
	 * @param {string} pluginName - Name of the plugin
	 * @param {string} methodName - Name of the method to extract (e.g., 'start', 'run')
	 * @returns {Function|null} - The requested method or null if not found
	 */
	async getPluginMethod(pluginName, methodName) {
		const plugin = await this.getPlugin(pluginName);

		if (!plugin) {
			return null;
		}

		const method = plugin[methodName];

		if (typeof method !== 'function') {
			console.warn(
				`Warning: Method '${methodName}' not found or is not a function in plugin '${pluginName}'`,
			);
			return null;
		}

		return method;
	}

	/**
	 * Discover all available plugins in the plugins directory
	 * @returns {string[]} - Array of plugin names
	 */
	discoverPlugins() {
		if (!fs.existsSync(this.pluginsBaseDir)) {
			console.warn(
				`Warning: Plugins directory does not exist: ${this.pluginsBaseDir}`,
			);
			return [];
		}

		const items = fs.readdirSync(this.pluginsBaseDir, { withFileTypes: true });
		const pluginNames = items
			.filter((dirent) => dirent.isDirectory())
			.map((dirent) => dirent.name);

		return pluginNames;
	}

	/**
	 * Get all discovered plugins with their metadata
	 * @returns {Object} - Object with plugin names as keys and metadata as values
	 */
	getAllPluginMetadata() {
		const pluginNames = this.discoverPlugins();
		const metadata = {};

		for (const pluginName of pluginNames) {
			const pluginDir = path.join(this.pluginsBaseDir, pluginName);
			const manifestPath = path.join(pluginDir, 'manifest.json');

			// Load plugin manifest if it exists
			if (fs.existsSync(manifestPath)) {
				try {
					const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
					metadata[pluginName] = {
						name: pluginName,
						manifest: manifest,
						hasConfig: fs.existsSync(path.join(pluginDir, 'config.json')),
					};
				} catch (error) {
					console.warn(
						`Warning: Could not load manifest for plugin ${pluginName}:`,
						error.message,
					);
					metadata[pluginName] = {
						name: pluginName,
						manifest: null,
						hasConfig: fs.existsSync(path.join(pluginDir, 'config.json')),
					};
				}
			} else {
				metadata[pluginName] = {
					name: pluginName,
					manifest: null,
					hasConfig: fs.existsSync(path.join(pluginDir, 'config.json')),
				};
			}
		}

		return metadata;
	}

	/**
	 * Reset the plugin cache (useful for development or reloading)
	 */
	clearCache() {
		this.pluginCache.clear();
	}

	/**
	 * Get cached plugin count
	 * @returns {number} - Number of cached plugins
	 */
	getCachedPluginCount() {
		return this.pluginCache.size;
	}

	/**
	 * Get list of cached plugin names
	 * @returns {string[]} - Array of cached plugin names
	 */
	getCachedPlugins() {
		return Array.from(this.pluginCache.keys());
	}
}

// Export singleton instance
export const pluginLoader = new PluginLoader();

// Also export the class for cases where multiple instances are needed
export default PluginLoader;


================================================================================

