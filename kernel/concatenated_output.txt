// File: app.js

import path from 'path';
import { fileURLToPath } from 'url';
import { manifestReader } from './contract.js';
import { buildConfig } from './utils/config-loader.js';
import { CommandProcessor } from './processor/CommandProcessor.js';
import { PluginLoader } from './utils/PluginLoader.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Launch the hosted application with the given arguments and project root
 * @param {string[]} args - Command line arguments
 * @param {string} projectRoot - The project root directory
 * @returns {Promise<void>}
 */
export async function launch(args, projectRoot) {
	// Build unified configuration once at the beginning
	// Calculate config path relative to this file's location (app.js is in kernel/ dir)
	const configFilePath = path.join(__dirname, 'config.json');
	const config = buildConfig(configFilePath, projectRoot);
	const manifest = manifestReader(config.paths.contractDir, projectRoot);
	const commandProcessor = new CommandProcessor(config, manifest);

	// Create plugin loader once and get the repl and cli plugins
	const pluginLoader = new PluginLoader(config.paths.pluginsDir);
	const replStart = await pluginLoader.getPluginMethod('repl', 'start');
	const cliRun = await pluginLoader.getPluginMethod('cli', 'run');

	if (!replStart || !cliRun) {
		console.error('‚ùå repl or cli plugin not found or invalid');
		process.exit(1);
	}

	// Default to REPL mode if no args or if args are application-specific
	if (args.length === 0) {
		// Default to REPL mode if no args
		return replStart(config.repl.paths.contextFilePath,config.repl.paths.replHistoryFilePath,config.repl.maxHistory, commandProcessor);
	} else {
		// Check if we're being called directly with command line args
		return cliRun(config.cli.paths.contextFilePath, commandProcessor, args);
	}
}

// Note: This file is not meant to be run directly. Use main.js in the project root.


================================================================================

<!-- File: config.json -->

{
	"paths": {
		"contractDir": "contract",
		"pluginsDir": "external-plugins"
	}
}


================================================================================

// File: contract.js

// manifestLoader.js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Loads and merges manifest from the new 4-file structure
 * @param {string} projectRoot - Root directory of the project
 * @returns {Object} - Complete merged manifest
 */
export function loadManifest(projectRoot) {
  // Load the four core files
  const contract = loadJSONFile(projectRoot, 'contract.json');
  const commands = loadJSONFile(projectRoot, 'commands.json');
  const runtime = loadJSONFile(projectRoot, 'runtime.json', {}); // Optional
  const help = loadJSONFile(projectRoot, 'help.json', {}); // Optional

  // Transform commands object into array with name property
  const commandArray = Object.entries(commands).map(([commandName, commandSpec]) => {
    return {
      name: commandName,
      ...commandSpec,
      // Merge runtime and help data for this command
      ...(runtime[commandName] || {}),
      ...(help[commandName] || {}),
      // Deep merge parameters from all sources
      parameters: mergeParameters(
        commandSpec.parameters,
        runtime[commandName]?.parameters,
        help[commandName]?.parameters
      )
    };
  });

  return {
    ...contract,
    commands: commandArray
  };
}

/**
 * Load a JSON file with optional default value
 */
function loadJSONFile(projectRoot, filename, defaultValue = null) {
  const filePath = path.join(projectRoot, filename);
  
  if (!fs.existsSync(filePath)) {
    if (defaultValue !== null) {
      return defaultValue;
    }
    throw new Error(`Required manifest file not found: ${filename}`);
  }

  try {
    return JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (error) {
    throw new Error(`Failed to parse ${filename}: ${error.message}`);
  }
}

/**
 * Deep merge parameters from multiple sources
 */
function mergeParameters(...paramSources) {
  const merged = {};
  
  for (const params of paramSources) {
    if (!params || typeof params !== 'object') continue;
    
    for (const [paramName, paramSpec] of Object.entries(params)) {
      if (merged[paramName]) {
        // Merge existing parameter spec
        merged[paramName] = { ...merged[paramName], ...paramSpec };
      } else {
        // Create new parameter spec
        merged[paramName] = { ...paramSpec };
      }
    }
  }
  
  return merged;
}

/**
 * Utility to validate the manifest structure
 */
export function validateManifest(manifest) {
  const errors = [];

  if (!manifest.sources || typeof manifest.sources !== 'object') {
    errors.push('Manifest must contain a sources object');
  }

  if (!Array.isArray(manifest.commands)) {
    errors.push('Manifest must contain a commands array');
  } else {
    manifest.commands.forEach((command, index) => {
      if (!command.name) {
        errors.push(`Command at index ${index} missing name property`);
      }
      if (!command.commandType) {
        errors.push(`Command '${command.name}' missing commandType`);
      }
      if (command.commandType === 'external-method' && !command.source) {
        errors.push(`External-method command '${command.name}' missing source property`);
      }
    });
  }

  if (errors.length > 0) {
    throw new Error(`Manifest validation failed:\n- ${errors.join('\n- ')}`);
  }

  return true;
}

// Updated version that works with the new loader
export function manifestReader(contractDir, projectRoot) {
  // For backward compatibility, but now we ignore contractDir 
  // and load from project root instead
  console.warn('Note: manifestReader now loads from project root, contractDir parameter is ignored');
  return loadManifest(projectRoot);
}

================================================================================

// File: kernel.js

import { buildConfig } from './utils/config-loader.js';
import { manifestReader } from './contract.js';
import { CommandProcessor } from './processor/CommandProcessor.js';
import { PluginLoader } from './utils/PluginLoader.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Launch the kernel infrastructure with the given arguments and project root
 * @param {string[]} args - Command line arguments
 * @param {string} projectRoot - The project root directory
 * @returns {Promise<void>}
 */
export async function launch(args, projectRoot) {
	// Build unified configuration once at the beginning
	// Calculate config path relative to this file's location (kernel.js is in kernel/ dir)
	const configFilePath = path.join(__dirname, 'config.json');
	const config = buildConfig(configFilePath, projectRoot);
	const manifest = manifestReader(config.paths.contractDir, projectRoot);
	const commandProcessor = new CommandProcessor(config, manifest);

	// Create plugin loader once for all plugin operations
	const pluginLoader = new PluginLoader(config.paths.pluginsDir);

	// Check if we should run in Electron
	if (args.includes('--electron')) {
		// Get the electron plugin and start it using the plugin loader
		const electronPlugin = await pluginLoader.getPlugin('electron');
		if (!electronPlugin) {
			console.error('‚ùå Electron plugin not found or invalid');
			process.exit(1);
		}

		return electronPlugin.start(
			config.paths.kernelDir
		);
	}
	// Check if we should regenerate UI with EJS templates
	else if (args.includes('--generate')) {
		// Get the generate plugin and run it using the plugin loader
		const generatePlugin = await pluginLoader.getPlugin('generate');
		if (!generatePlugin) {
			console.error('‚ùå Generate plugin not found or invalid');
			process.exit(1);
		}

		return generatePlugin
			.run(
				config.generate.paths.userTemplateDir,
				config.generate.paths.generatedUIDir,
				manifest,
				commandProcessor,
			)
			.then(() => {
				console.log('‚úÖ EJS-based UI generation completed successfully!');
				process.exit(0);
			})
			.catch((err) => {
				console.error('‚ùå Failed to generate EJS-based UI:', err.message);
				process.exit(1);
			});
	}
	// Check if we should start HTTP server (now serves both UI and API, like old --serve)
	else if (args.includes('--http')) {
		// Get the HTTP plugin and start server that serves both UI and API
		const httpPlugin = await pluginLoader.getPlugin('http');
		if (!httpPlugin) {
			console.error('‚ùå HTTP plugin not found or invalid');
			process.exit(1);
		}

		return httpPlugin.start(
			config.http.port,
			config.http.paths.servedUIDir,
			config.http.apiEndpoint,
			commandProcessor,
		);
	} else {
		// For other kernel commands or to show help
		console.log('Kernel command-line interface');
		console.log('Available commands:');
		console.log(
			'  --generate             Generate UI from contracts using EJS templates',
		);
		console.log(
			'  --http                 Serve UI and API on specified port (default 8080)',
		);
		console.log('  --electron             Launch Electron application');
		process.exit(0);
	}
}

// Note: This file is not meant to be run directly. Use kernel.js in the project root.


================================================================================

<!-- File: README.md -->

# üß† Vertex Kernel Framework

A domain-agnostic command processing engine that automatically discovers and executes commands defined in your domain-specific contract, with support for multiple transports and built-in command types.

## üéØ Purpose

Vertex provides a universal command processing system that works with any domain. Simply define your commands in a contract folder and the kernel automatically discovers, validates, and executes them through multiple interfaces.

## üìÅ Project Structure

```
your-project/
‚îú‚îÄ‚îÄ kernel/                    # Generic command engine (copy once) - "Vertex"
‚îÇ   ‚îú‚îÄ‚îÄ utils/                 # Shared utilities
‚îÇ   ‚îú‚îÄ‚îÄ contract.js            # Contract loading and management
‚îÇ   ‚îú‚îÄ‚îÄ CommandHandler.js      # Core command processing
‚îÇ   ‚îú‚îÄ‚îÄ CommandProcessor.js    # Command pipeline with state management
‚îÇ   ‚îî‚îÄ‚îÄ CommandParser.js       # Command parsing from user input
‚îú‚îÄ‚îÄ external-plugins/          # Configurable plugin directory (configurable via config.json)
‚îÇ   ‚îú‚îÄ‚îÄ cli/                   # CLI interface
‚îÇ   ‚îú‚îÄ‚îÄ repl/                  # REPL interface
‚îÇ   ‚îú‚îÄ‚îÄ http/                  # HTTP server and API
‚îÇ   ‚îú‚îÄ‚îÄ electron/              # Electron desktop application
‚îÇ   ‚îî‚îÄ‚îÄ generator/             # UI generation system
‚îú‚îÄ‚îÄ contract/                  # Your domain-specific commands
‚îÇ   ‚îú‚îÄ‚îÄ global.json            # Domain configuration
‚îÇ   ‚îî‚îÄ‚îÄ [command-name]/        # Directory for each command
‚îÇ       ‚îú‚îÄ‚îÄ manifest.json      # Command definition
‚îÇ       ‚îú‚îÄ‚îÄ runtime.json       # Runtime behavior
‚îÇ       ‚îú‚îÄ‚îÄ help.json          # User documentation
‚îÇ       ‚îî‚îÄ‚îÄ handler.js         # Custom command implementation (optional)
‚îú‚îÄ‚îÄ yourDomain/                # Domain-specific logic
‚îú‚îÄ‚îÄ generated-ui/              # Auto-generated web interface
‚îî‚îÄ‚îÄ main.js                    # Your project's entry point
```

Note: The contract loader (`kernel/contract.js`) focuses solely on manifest loading and caching, with module path resolution performed ahead-of-time to simplify command execution. The plugin system is fully configurable via `"pluginsDir"` in the kernel config.

## üöÄ Quick Start

### 1. Copy Vertex

Copy the entire `/kernel` directory to your project. This is the universal command engine - you never need to modify it.

### 2. Create Your Contract

Create a `/contract` directory with your domain-specific commands:

**contract/global.json**

```json
{
	"name": "your-app-name",
	"version": "1.0.0",
	"description": "Your application description",
	"prompt": "> ",
	"stateDefaults": {
		"currentUser": null,
		"currentProject": null
	}
}
```

**contract/yourcommand/manifest.json**

```json
{
	"name": "yourcommand",
	"commandType": "external-method",
	"modulePath": "yourDomain/index.js",
	"methodName": "yourDomainMethod",
	"description": "Description of what your command does",
	"syntax": "yourcommand(param1, [options])",
	"parameters": {
		"param1": {
			"type": "string",
			"required": true,
			"description": "Required parameter"
		}
	}
}
```

### 3. Configure Plugin Directory (Optional)

You can configure where plugins are loaded from in `kernel/config.json`:

```json
{
	"paths": {
		"pluginsDir": "external-plugins" // or "kernel/plugins", "/absolute/path", etc.
	}
}
```

### 4. Create Your Entry Point

Create a `main.js` file at your project root:

```javascript
#!/usr/bin/env node
import { launch } from './kernel/app.js';

// Launch with current directory as project root
const projectRoot = process.cwd();
launch(process.argv.slice(2), projectRoot);
```

The entry point delegates to Vertex, maintaining clean separation of concerns.

### 5. Run Your Application

```bash
# CLI mode
node main.js yourcommand param1=value1

# REPL mode
node main.js

# Generate web UI
node main.js --generate

# Serve web UI and API (uses --http which now serves both UI and API)
node main.js --http

# Launch Electron app
node main.js --electron
```

## üß† Command Types

Vertex supports three distinct command types with different handling strategies:

### 1. External-Method Commands (`commandType: "external-method"`)

Automatically handled by calling domain methods:

```json
{
	"name": "yourCommand",
	"commandType": "external-method",
	"modulePath": "yourDomain/index.js",
	"methodName": "yourMethod"
}
```

No handler file needed - the kernel automatically calls `yourDomain.yourMethod()`.

### 2. Internal Commands (`commandType: "internal"`)

Handled declaratively with template-based output:

```json
{
	"name": "use",
	"commandType": "internal",
	"successOutput": "‚úÖ Using value: {{someParamValue}}",
	"parameters": {}
}
```

No handler file needed - behavior defined entirely in manifest.

### 3. Custom Commands (`commandType: "custom"`)

Require custom handler implementation:

```json
{
	"name": "randomize",
	"commandType": "custom"
}
```

Must provide `handler.js` with custom logic.

## üîÑ Transport System

Vertex provides multiple interfaces to access your commands:

### CLI Transport

Execute commands directly from the command line:

```bash
node main.js yourcommand param=value
```

### REPL Transport

Interactive shell with tab completion:

```bash
node main.js
> yourcommand param=value
```

### HTTP Transport

HTTP server serving both web UI and API:

```bash
# Start server with UI and API
node main.js --http

# Make API calls
GET http://localhost:8080?json={"name":"yourcommand","args":{"param":"value"}}
POST http://localhost:8080/api with JSON body

# UI available at: http://localhost:8080/
# API available at: http://localhost:8080/api
```

### Electron Transport

Desktop application with native UI. Uses dynamic kernel loading:

- `external-plugins/electron/electron-main.js` - Entry point that dynamically loads kernel modules
- `external-plugins/electron/KernelLoader.js` - Handles dynamic module loading at runtime

```bash
# Launch Electron app
node main.js --electron
```

## üß© How It Works

### Automatic Command Discovery

The kernel automatically scans your `/contract` directory and discovers all commands by reading their manifest files.

### Three-File Contract System

Commands are defined across three JSON files:

- `manifest.json` - Core kernel requirements (type, paths, params)
- `runtime.json` - Runtime behavior (defaults, validation, side effects)
- `help.json` - User documentation (descriptions, examples)

### Smart Command Routing

Based on `commandType` in manifests:

- **`external-method`**: Kernel automatically calls specified domain method with ahead-of-time path resolution
- **`internal`**: Kernel handles declaratively using manifest templates
- **`custom`**: Kernel delegates to custom `handler.js` implementation with on-demand loading

### Multiple Transports, Single Interface

All command types work seamlessly across all transports - write once, use everywhere.

### Zero Domain Coupling

The kernel contains zero domain-specific logic. All domain configuration and business logic lives in your `/contract` and `/yourDomain` folders.

## üõ†Ô∏è Advanced Features

### Configurable Plugin Directory

The plugin system supports configurable plugin directories:

- Set `"pluginsDir"` in `kernel/config.json`
- Can point to internal or external directories
- Uses path resolver for consistent path handling

### Dynamic Kernel Loading

The Electron plugin uses advanced dynamic loading:

- Kernel modules loaded dynamically based on runtime paths
- Two path arguments passed: `--project-root` and `--kernel-path`
- Maintains independence from hardcoded paths

### State Management

The kernel provides persistent state management:

```json
// In global.json
{
  "stateDefaults": {
    "currentUser": null,
    "currentProject": null,
    "lastResult": null
  }
}

// In command manifest
{
  "sideEffects": {
    "setState": {
      "currentProject": { "fromParam": "projectName" },
      "lastResult": { "template": "Processed {{fileName}}" }
    }
  }
}
```

### Runtime Fallbacks

Parameters can automatically fall back to state values:

```json
{
	"parameters": {
		"projectName": {
			"type": "string",
			"required": true,
			"runtimeFallback": "currentProject"
		}
	}
}
```

### Template Strings

Use template strings for dynamic values:

```json
{
	"sideEffects": {
		"setState": {
			"currentProject": { "fromParam": "projectName" },
			"projectFile": { "template": "{{projectName}}.json" }
		}
	}
}
```

## üåê Web UI Generation

The kernel automatically generates complete web interfaces from your contract manifests:

- Single-page application with dynamic forms
- Parameter-specific input fields
- Real-time API integration
- State management and fallbacks

Generate UI with: `node main.js --generate`

Just copy Vertex once and focus on writing your domain-specific commands!


================================================================================

// File: processor\CommandHandler.js

import { pathToFileURL } from 'url';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class CommandHandler {
	constructor(manifest, config = {}) {
		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('CommandHandler requires a manifest object');
		}

		// Validate config parameter
		if (typeof config !== 'object' || config === null) {
			throw new Error('CommandHandler requires a config object');
		}

		// Extract contractDir from paths in config
		if (!config.paths || !config.paths.contractDir) {
			throw new Error(
				'CommandHandler config requires paths.contractDir property',
			);
		}

		this.manifest = manifest;
		this.config = config;
		this.contractDir = config.paths.contractDir;
		
		// Initialize source cache for shared module instances
		this.sourceCache = new Map();
	}

	/**
	 * Handle a parsed command
	 * @param {Object} command - The command object
	 * @returns {Promise<Object>} - The result of the command
	 */
	async handleCommand(command) {
		if (!command) return;
		
		try {
			// Get the command specification from the manifest
			const commandSpec = this.manifest.commands.find(
				(c) => c.name === command.name,
			);

			if (!commandSpec) {
				return {
					error: `Unknown command: ${command.name}`,
					output: null,
				};
			}

			// Handle internal commands declaratively
			if (commandSpec.commandType === 'internal') {
				return this.handleInternalCommand(command, commandSpec);
			}

			// Handle external-method commands using source system
			if (commandSpec.commandType === 'external-method') {
				return await this.handleExternalMethod(command, commandSpec);
			}

			// If we get here, it's an unknown command type
			return {
				error: `Unknown command type '${commandSpec.commandType}' for command '${command.name}'`,
				output: null,
			};
		} catch (error) {
			return {
				error: `Error processing command: ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Handle a declarative internal command
	 * @param {Object} command - The parsed command object
	 * @param {Object} commandSpec - The command manifest specification
	 * @returns {Object} - The result of the command
	 */
	handleInternalCommand(command, commandSpec) {
		const { args = {} } = command;

		// Validate required parameters
		if (commandSpec.parameters) {
			for (const paramName in commandSpec.parameters) {
				const param = commandSpec.parameters[paramName];
				if (
					param.required &&
					(args[paramName] === undefined || args[paramName] === null)
				) {
					return {
						error: `Parameter '${paramName}' is required for command '${commandSpec.name}'`,
						output: null,
					};
				}
			}
		}

		// Generate success output from template if provided
		let output = null;
		if (commandSpec.successOutput) {
			output = this.renderTemplate(commandSpec.successOutput, args);
		}

		return {
			error: null,
			output: output,
		};
	}

	/**
	 * Get or load a source module
	 * @param {string} sourceSpec - The source name from global.json
	 * @returns {Promise<Object>} - The loaded module
	 */
	async getSource(sourceSpec) {
		// Check if source is already cached
		if (this.sourceCache.has(sourceSpec)) {
			return this.sourceCache.get(sourceSpec);
		}

		// Look up the source path in global manifest
		const sourcePath = this.manifest.sources?.[sourceSpec];
		
		if (!sourcePath) {
			throw new Error(`Source '${sourceSpec}' not found in global.json`);
		}

		// Resolve the source path relative to project root if it's a local path
		let resolvedPath;
		if (sourcePath.startsWith('./') || sourcePath.startsWith('../')) {
			// Local path - resolve relative to project root
			const projectRoot = this.config.paths?.projectRoot;
			if (!projectRoot) {
				throw new Error(`Cannot resolve local source '${sourceSpec}': projectRoot not available`);
			}
			resolvedPath = path.resolve(projectRoot, sourcePath);
			
			// Handle directory imports
			if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
				// First, check for package.json with main entry
				const packageJsonPath = path.join(resolvedPath, 'package.json');
				if (fs.existsSync(packageJsonPath)) {
					try {
						const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
						if (packageJson.main) {
							resolvedPath = path.resolve(resolvedPath, packageJson.main);
						} else {
							// package.json exists but no main? Fall back to index.js
							resolvedPath = path.join(resolvedPath, 'index.js');
						}
					} catch (error) {
						// If package.json is invalid, fall back to index.js
						resolvedPath = path.join(resolvedPath, 'index.js');
					}
				} else {
					// No package.json? Straight to index.js fallback
					resolvedPath = path.join(resolvedPath, 'index.js');
				}
			}
			
			// Ensure it has .js extension if it's still a file path without one
			if (!resolvedPath.endsWith('.js') && !resolvedPath.endsWith('.mjs')) {
				resolvedPath += '.js';
			}
		} else {
			// npm package - use as-is
			resolvedPath = sourcePath;
		}

		// Check if the resolved file exists
		if (!fs.existsSync(resolvedPath)) {
			throw new Error(`Source file not found: ${resolvedPath}`);
		}

		// Convert to file URL for proper ES module loading
		const moduleUrl = pathToFileURL(resolvedPath).href;

		// Dynamically import the module
		const module = await import(moduleUrl);

		// Cache the module for future use
		this.sourceCache.set(sourceSpec, module);

		return module;
	}

	/**
	 * Handle an external-method command using source resolution with caching
	 * @param {Object} command - The parsed command object
	 * @param {Object} commandSpec - The command manifest specification
	 * @returns {Promise<Object>} - The result of the command
	 */
	async handleExternalMethod(command, commandSpec) {
		const { args = {} } = command;

		try {
			// Get the source spec from the command manifest
			const sourceSpec = commandSpec.source;
			
			if (!sourceSpec) {
				return {
					error: `External-method command '${commandSpec.name}' missing 'source' property in manifest`,
					output: null,
				};
			}

			// Get the module from cache or load it
			const module = await this.getSource(sourceSpec);

			// Get the method from the module
			const method = module[commandSpec.methodName];

			// Check if method exists with better error reporting
			if (typeof method !== 'function') {
				const availableMethods = Object.keys(module).filter(key => typeof module[key] === 'function');
				return {
					error: `Method '${commandSpec.methodName}' not found in source '${sourceSpec}'. Available methods: ${availableMethods.join(', ') || 'none'}`,
					output: null,
				};
			}

			// Call the method with the command arguments
			try {
				const result = await method(args);
				// Treat the result as success output
				return {
					error: null,
					output: result,
				};
			} catch (methodError) {
				// If the method throws an error, convert it to the expected format
				return {
					error: methodError.message,
					output: null,
				};
			}
		} catch (error) {
			return {
				error: `Failed to execute external method '${commandSpec.methodName}' from source '${commandSpec.source}': ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Simple template renderer that substitutes {{paramName}} with parameter values
	 * @param {string} template - Template string with {{param}} placeholders
	 * @param {Object} params - Parameter values to substitute
	 * @returns {string} - Rendered template
	 */
	renderTemplate(template, params) {
		if (!template || typeof template !== 'string') {
			return '';
		}

		return template.replace(/\{\{([^}]+)\}\}/g, (match, paramName) => {
			const trimmedParamName = paramName.trim();
			if (params && params.hasOwnProperty(trimmedParamName)) {
				return String(params[trimmedParamName]);
			}
			return match; // Keep original placeholder if param not found
		});
	}

	/**
	 * Get cached source count (for debugging/monitoring)
	 * @returns {number} - Number of cached sources
	 */
	getCachedSourceCount() {
		return this.sourceCache.size;
	}

	/**
	 * Get list of cached sources (for debugging/monitoring)
	 * @returns {string[]} - Array of cached source names
	 */
	getCachedSources() {
		return Array.from(this.sourceCache.keys());
	}

	/**
	 * Clear the source cache (useful for development/reloading)
	 */
	clearCache() {
		this.sourceCache.clear();
	}
}

================================================================================

// File: processor\CommandParser.js

import { parseObjectStyle } from './parsers/Objective.js';
import { parseFunctionStyle } from './parsers/Functional.js';
/**
 * Command parser for REPL-style interface
 *
 * Supports both function-style and object-style syntax:
 * - command("param1", "param2", key=value)
 * - command({param1: "value1", key: value2})
 * - command param1 param2 key=value
 */
export class CommandParser {
	constructor(manifest) {
		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('CommandParser requires a manifest object');
		}

		this.manifest = manifest;
		this.patterns = {
			objectCall: /^(\w+)\s*\(\s*(\{.*\})\s*\)\s*$/,
			funcCall: /^(\w+)\s*\(\s*([^)]*)\s*\)\s*$/,
			simpleCommand: /^(\w+)\s*$/,
			cliStyle: /^(\w+)\s+(.+)$/,
		};
	}

	/**
	 * Parse a command string into a command object
	 * @param {string} input - The command string to parse
	 * @param {Object} context - Optional context with runtime state
	 * @returns {{error: string|null, command: Object|null}}
	 */
	parse(input, context = {}) {
		if (!input || typeof input !== 'string') {
			return {
				error: 'Invalid input: must be a non-empty string',
				command: null,
			};
		}

		const trimmed = input.trim();

		// First, try to parse as JSON command object
		try {
			const commandObj = JSON.parse(trimmed);
			if (commandObj && typeof commandObj === 'object' && commandObj.name) {
				// This is a valid JSON command object
				return {
					error: null,
					command: commandObj,
				};
			}
		} catch (jsonError) {
			// Not a JSON command object, continue with string parsing
		}

		// Try CLI-style parsing first
		const cliMatch = trimmed.match(this.patterns.cliStyle);
		if (cliMatch) {
			const spec = this.manifest.commands.find(
				(c) => c.name.toLowerCase() === cliMatch[1].toLowerCase(),
			);
			if (
				!(
					spec &&
					Object.entries(spec.parameters || {}).every(([_, p]) => !p.required)
				)
			) {
				return this.parseCliStyle(cliMatch[1], cliMatch[2], context);
			}
		}

		// Try object style first (backward compatible)
		const objectMatch = trimmed.match(this.patterns.objectCall);
		if (objectMatch) {
			return this.parseObjectStyle(objectMatch);
		}

		// Try function style
		const funcMatch = trimmed.match(this.patterns.funcCall);
		if (funcMatch) {
			return this.parseFunctionStyle(funcMatch);
		}

		// Try simple command
		const simpleMatch = trimmed.match(this.patterns.simpleCommand);
		if (simpleMatch) {
			const funcCall = `${trimmed}()`;
			const match = funcCall.match(this.patterns.funcCall);
			if (match) return this.parseFunctionStyle(match, context);
		}

		return {
			error: `Could not parse command: ${input}`,
			command: null,
		};
	}

	parseCliStyle(command, argsString, context = {}) {
		const spec = this.manifest.commands.find(
			(c) => c.name.toLowerCase() === command.toLowerCase(),
		);
		if (!spec) return { error: `Unknown command: ${command}`, command: null };

		const required = Object.entries(spec.parameters || {})
			.filter(([_, p]) => p.required)
			.map(([name, param]) => ({ name, ...param }));
		const parts = argsString.split(/\s+/).filter(Boolean);

		// Split into positional vs named pieces
		const positional = [];
		const named = [];

		for (const part of parts) {
			if (part.includes('=')) {
				named.push(part);
			} else {
				positional.push(part); // Remove JSON.stringify to avoid extra quotes
			}
		}

		// Map positional tokens to required parameters in order
		if (positional.length > required.length) {
			return {
				error: `Too many positional parameters for ${command}`,
				command: null,
			};
		}
		const positionalPairs = required
			.slice(0, positional.length)
			.map((p, i) => `${p.name}="${positional[i]}"`);

		// Build final function-style string
		const funcCall = `${command}(${[...positionalPairs, ...named].join(',')})`; // Remove space after comma
		const match = funcCall.match(this.patterns.funcCall);

		return this.parseFunctionStyle(match, context);
	}

	/**
	 * Parse a command in object style
	 * @param {string[]} - Destructured match from regex
	 * @param {Object} context - Optional context with runtime state
	 * @returns {{error: string|null, command: Object|null}}
	 */
	parseObjectStyle([, name, argsString], context = {}) {
		return parseObjectStyle([, name, argsString], context, this.manifest);
	}

	/**
	 * Parse a command in function style
	 * @param {string[]} - Destructured match from regex
	 * @param {Object} context - Optional context with runtime state
	 * @returns {{error: string|null, command: Object|null}}
	 */
	parseFunctionStyle([, name, argsString], context = {}) {
		return parseFunctionStyle([, name, argsString], context, this.manifest);
	}
}


================================================================================

// File: processor\CommandProcessor.js

import { CommandParser } from './CommandParser.js';
import { CommandHandler } from './CommandHandler.js';
import StateManager from './StateManager.js';

/**
 * Consolidates shared command processing logic across all transports
 */
export class CommandProcessor {
	constructor(config, manifest) {
		// Validate config parameter
		if (!config || typeof config !== 'object') {
			throw new Error('CommandProcessor requires a config object');
		}



		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('CommandProcessor requires a manifest object');
		}

		// Validate contractDir in config paths
		if (!config.paths.contractDir) {
			throw new Error(
				'CommandProcessor config requires paths.contractDir property',
			);
		}

		this.manifest = manifest;
		this.stateManager = new StateManager(manifest);
		this.parser = new CommandParser(manifest);
		// Pass the full config to CommandHandler
		this.handler = new CommandHandler(manifest, config); // Pass manifest and full config to CommandHandler
		this.state = this.stateManager.getStateMap();
	}

	/**
	 * Process a command through the complete pipeline
	 * @param {string} input - The command input string (can be JSON or string format)
	 * @param {string|null} contextFilePath - Path to context file for state management (default: null, uses default state)
	 * @param {boolean} formatToString - Whether to format the result to a string (default: true)
	 * @returns {Promise<Object>} - The result of command processing
	 */
	async processCommand(input, contextFilePath = null, formatToString = true) {
		try {
			const trimmedInput = input.trim().toLowerCase();

			// Handle special built-in commands before parsing
			if (
				trimmedInput === 'help' ||
				trimmedInput === 'help()' ||
				trimmedInput.startsWith('help(')
			) {
				// Create a help command object
				let args = {};
				if (
					trimmedInput.startsWith('help(') &&
					input.includes('(') &&
					input.includes(')')
				) {
					// Extract any specific command from help(command)
					const paramMatch = input.match(
						/help\\(\\s*["']?([^"')\\s]+)["']?\\s*\\)/i,
					);
					if (paramMatch && paramMatch[1]) {
						args = { command: paramMatch[1] };
					}
				}

				const context = {
					state: this.state,
					manifest: this.manifest,
				};

				const result = await this.handleHelpCommand(args, context);
				return result;
			}

			if (trimmedInput === 'exit' || trimmedInput === 'exit()') {
				const result = await this.handleExitCommand();
				// Exit command returns a special result for transports to handle
				return {
					output: 'Goodbye!',
					exit: true,
				};
			}

			// For all other commands, create context and parse normally
			const context = {
				state: this.state,
				manifest: this.manifest,
			};

			// Parse the command using the unified parser
			const { error, command } = this.parser.parse(input, context);

			if (error) {
				return { error, output: null };
			}

			// Execute the command through the handler
			const result = await this.handler.handleCommand(command);

			// Apply side effects and save state if command was successful and context file path is provided
			if (!result.error && contextFilePath !== null) {
				const commandSpec = this.manifest.commands.find(
					(c) => c.name === command.name,
				);
				if (commandSpec) {
					this.stateManager.applySideEffects(command, commandSpec);
					this.stateManager.saveState(contextFilePath);
				}
			}
			return result;
		} catch (error) {
			return {
				error: `Command processing error: ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Handle the help command logic inline
	 * @param {Object} args - Arguments for the help command
	 * @param {Object} context - Execution context
	 * @returns {Object} - Result of the help command
	 */
	async handleHelpCommand(args, context) {
		const { manifest } = context;
		const { command: specificCommand } = args;

		if (specificCommand) {
			// Show help for specific command
			const cmd = manifest.commands.find((c) => c.name === specificCommand);
			if (!cmd) {
				return { error: `Unknown command: ${specificCommand}` };
			}

			return { output: this.formatCommandHelp(cmd) };
		} else {
			// Show general help
			return { output: this.formatGeneralHelp(manifest) };
		}
	}

	/**
	 * Format general help text
	 * @param {Object} manifest - The application manifest
	 * @returns {string} Formatted help text
	 */
	formatGeneralHelp(manifest) {
		let helpText = `üîó ${manifest.name} - ${manifest.description}\n`;
		helpText += '='.repeat(Math.max(manifest.name.length + 2, 40)) + '\n\n';
		helpText += 'Available commands:\n';

		// Sort commands alphabetically
		const sortedCommands = [...manifest.commands].sort((a, b) =>
			a.name.localeCompare(b.name),
		);

		for (const cmd of sortedCommands) {
			helpText += `${cmd.name}${this.formatParamsSignature(cmd)} - ${cmd.description}\n`;
		}

		helpText += '\nhelp([command]) - Show help information\n';
		helpText += 'exit() - Exit the program\n';
		helpText += '\nCommand Syntax:\n';
		helpText += '‚Ä¢ Function style: command(param1, param2, key=value)\n';
		helpText += '‚Ä¢ Object style: command({param1: value, key: value})\n';
		helpText += '‚Ä¢ Simple style: command\n';

		return helpText;
	}

	/**
	 * Format help for a specific command
	 * @param {Object} cmd - The command manifest
	 * @returns {string} Formatted command help
	 */
	formatCommandHelp(cmd) {
		let helpText = `üîó ${cmd.name}${this.formatParamsSignature(cmd)}\n`;
		helpText += '   ' + cmd.description + '\n\n';

		const requiredParams = cmd.parameters
			? Object.entries(cmd.parameters)
					.filter(([_, p]) => p.required)
					.map(([name, param]) => ({ name, ...param }))
			: [];
		const optionalParams = cmd.parameters
			? Object.entries(cmd.parameters)
					.filter(([_, p]) => !p.required)
					.map(([name, param]) => ({ name, ...param }))
			: [];

		if (requiredParams.length > 0) {
			helpText += '   Required:\n';
			for (const param of requiredParams) {
				helpText += `       ${param.name} - ${param.description}\n`;
			}
			helpText += '\n';
		}

		if (optionalParams.length > 0) {
			helpText += '   Options (key=value):\n';
			for (const param of optionalParams) {
				const defaultValue =
					param.default !== undefined ? ` (default: ${param.default})` : '';
				const constraints = this.formatParamConstraints(param);
				const constraintText = constraints ? ` ${constraints}` : '';
				helpText += `       ${param.name}=${param.type}${defaultValue}${constraintText} - ${param.description}\n`;
			}
			helpText += '\n';
		}

		if (cmd.examples && cmd.examples.length > 0) {
			helpText += '   Examples:\n';
			for (const example of cmd.examples) {
				helpText += `       ${example}\n`;
			}
		}

		return helpText;
	}

	/**
	 * Format parameter signature for a command
	 * @param {Object} cmd - The command manifest
	 * @returns {string} Formatted parameter signature
	 */
	formatParamsSignature(cmd) {
		if (!cmd.parameters || Object.keys(cmd.parameters).length === 0) {
			return '()';
		}

		const required = Object.entries(cmd.parameters)
			.filter(([_, p]) => p.required)
			.map(([name, param]) => ({ name, ...param }));
		const optional = Object.entries(cmd.parameters)
			.filter(([_, p]) => !p.required)
			.map(([name, param]) => ({ name, ...param }));

		const requiredStr = required.map((p) => p.name).join(', ');
		const optionalStr = optional.map((p) => `[${p.name}]`).join(', ');

		let paramsStr = '';
		if (required.length > 0 && optional.length > 0) {
			paramsStr = `${requiredStr}, ${optionalStr}`;
		} else if (required.length > 0) {
			paramsStr = requiredStr;
		} else if (optional.length > 0) {
			paramsStr = optionalStr;
		}

		return `(${paramsStr})`;
	}

	/**
	 * Format parameter constraints for display
	 * @param {Object} param - The parameter manifest
	 * @returns {string} Formatted constraints
	 */
	formatParamConstraints(param) {
		const constraints = [];

		if (param.min !== undefined) {
			constraints.push(`min: ${param.min}`);
		}
		if (param.max !== undefined) {
			constraints.push(`max: ${param.max}`);
		}
		if (param.enum) {
			constraints.push(`one of: [${param.enum.join(', ')}]`);
		}

		return constraints.length > 0 ? `(${constraints.join(', ')})` : '';
	}

	/**
	 * Handle the exit command (no special logic needed, just return exit indication)
	 * @returns {Object} - Result of the exit command
	 */
	async handleExitCommand() {
		return {
			output: 'Goodbye!',
			exit: true,
		};
	}

	/**
	 * Process a command and apply side effects manually
	 * @param {Object} command - The parsed command object
	 * @param {string|null} contextFilePath - Path to context file for state management (default: null, uses default state)
	 * @param {boolean} formatToString - Whether to format the result to a string (default: true)
	 * @returns {Promise<Object>} - The result of command processing
	 */
	async processParsedCommand(
		command,
		contextFilePath = null,
		formatToString = true,
	) {
		try {
			// Execute the command through the handler
			const result = await this.handler.handleCommand(command);

			// Apply side effects and save state if command was successful and context file path is provided
			if (!result.error && contextFilePath !== null) {
				const commandSpec = this.manifest.commands.find(
					(c) => c.name === command.name,
				);
				if (commandSpec) {
					this.stateManager.applySideEffects(command, commandSpec);
					this.stateManager.saveState(contextFilePath);
				}
			}

			// Optionally format the result to a string if requested

			return result;
		} catch (error) {
			return {
				error: `Command processing error: ${error.message}`,
				output: null,
			};
		}
	}

	/**
	 * Get the current state
	 * @returns {Map} - The current state map
	 */
	getState() {
		return this.state;
	}

	/**
	 * Get the manifest
	 * @returns {Object} - The application manifest
	 */
	getManifest() {
		return this.manifest;
	}

	/**
	 * Get the parser instance
	 * @returns {CommandParser} - The command parser
	 */
	getParser() {
		return this.parser;
	}

	/**
	 * Get the handler instance
	 * @returns {CommandHandler} - The command handler
	 */
	getHandler() {
		return this.handler;
	}
}


================================================================================

// File: processor\StateManager.js

import fs from 'fs';
import path from 'path';

/**
 * Manages persistent state for the application
 */
export class StateManager {
	constructor(manifest) {
		// Validate manifest parameter
		if (!manifest || typeof manifest !== 'object') {
			throw new Error('StateManager requires a manifest object');
		}

		this.manifest = manifest;
		this.state = new Map(Object.entries(this.manifest.stateDefaults || {}));
		// Don't load state in constructor, only when provided
	}

	/**
	 * Load state from persistent storage
	 */
	loadState(contextFilePath = null) {
		try {
			if (contextFilePath && fs.existsSync(contextFilePath)) {
				const stateData = fs.readFileSync(contextFilePath, 'utf8');
				const savedState = JSON.parse(stateData);
				if (savedState && typeof savedState === 'object') {
					// Load only valid state keys from manifest defaults
					const defaultState = this.manifest.stateDefaults || {};
					for (const [key, defaultValue] of Object.entries(defaultState)) {
						if (key in savedState) {
							this.state.set(key, savedState[key]);
						} else {
							// Ensure defaults are present
							this.state.set(key, defaultValue);
						}
					}
				}
			}
		} catch (error) {
			console.warn(
				'‚ö†Ô∏è Could not load persistent state, using defaults:',
				error.message,
			);
			// Initialize with manifest defaults
			const defaultState = this.manifest.stateDefaults || {};
			for (const [key, value] of Object.entries(defaultState)) {
				this.state.set(key, value);
			}
		}
	}

	/**
	 * Save state to persistent storage
	 */
	saveState(contextFilePath = null) {
		if (!contextFilePath) return; // Don't save if no file path provided
		try {
			// Ensure context directory exists
			const contextDir = path.dirname(contextFilePath);
			if (!fs.existsSync(contextDir)) {
				fs.mkdirSync(contextDir, { recursive: true });
			}

			// Create serializable state object with only the default state keys
			const defaultState = this.manifest.stateDefaults || {};
			const stateToSave = {};

			for (const [key] of Object.entries(defaultState)) {
				if (this.state.has(key)) {
					stateToSave[key] = this.state.get(key);
				}
			}

			fs.writeFileSync(
				contextFilePath,
				JSON.stringify(stateToSave, null, 2),
			);
		} catch (error) {
			console.warn('‚ö†Ô∏è Could not save persistent state:', error.message);
		}
	}

	/**
	 * Get value from state
	 * @param {string} key - State key
	 * @returns {*} Value or undefined if not set
	 */
	get(key) {
		return this.state.get(key);
	}

	/**
	 * Set value in state
	 * @param {string} key - State key
	 * @param {*} value - Value to set
	 */
	set(key, value) {
		this.state.set(key, value);
	}

	/**
	 * Check if key exists in state
	 * @param {string} key - State key
	 * @returns {boolean} True if key exists
	 */
	has(key) {
		return this.state.has(key);
	}

	/**
	 * Delete key from state
	 * @param {string} key - State key to delete
	 */
	delete(key) {
		return this.state.delete(key);
	}

	/**
	 * Get the entire state as a Map
	 * @returns {Map} Current state
	 */
	getStateMap() {
		return this.state;
	}

	/**
	 * Apply side effects to state based on command manifest
	 * @param {Object} command - Command object
	 * @param {Object} commandManifest - Manifest for the executed command
	 */
	applySideEffects(command, commandManifest) {
		if (!commandManifest?.sideEffects) return;

		if (commandManifest.sideEffects.setState) {
			for (const [key, rule] of Object.entries(
				commandManifest.sideEffects.setState,
			)) {
				let value;

				if (rule.fromParam && command.args) {
					value = command.args[rule.fromParam];
				}
				if (value === undefined && rule.template && command.args) {
					// Apply template string with available parameters
					value = this.evaluateTemplate(rule.template, command.args);
				}

				if (value !== undefined) {
					this.state.set(key, value);
				}
			}
		}

		if (commandManifest.sideEffects.clearState) {
			for (const key of commandManifest.sideEffects.clearState) {
				this.state.delete(key);
			}
		}

		if (commandManifest.sideEffects.clearStateIf) {
			for (const [key, rule] of Object.entries(
				commandManifest.sideEffects.clearStateIf,
			)) {
				if (
					rule.fromParam &&
					command.args &&
					command.args[rule.fromParam] !== undefined
				) {
					const paramValue = command.args[rule.fromParam];
					const stateValue = this.state.get(key);

					// Clear state if the parameter value matches the current state value
					if (paramValue === stateValue) {
						this.state.delete(key);
					}
				}
			}
		}
	}

	/**
	 * Helper to evaluate template strings
	 * @private
	 */
	evaluateTemplate(template, bag) {
		return template.replace(
			/\{\{(\w+)(?:\s*\|\s*(\w+))?\}\}/g,
			(_, key, filter) => {
				let val = bag[key];
				if (val === undefined) return '';

				if (filter === 'basename') {
					val = String(val).replace(/\.[^/.]+$/, '');
				}

				return String(val);
			},
		);
	}
}

// Export the class, but not the singleton since it now requires a paths parameter
export default StateManager;


================================================================================

// File: processor\parsers\Functional.js

import { ParserUtils } from './Utils.js';

/**
 * Parse a command in function style
 * @param {string[]} match - Destructured match from regex
 * @param {Object} context - Optional context with runtime state
 * @param {Object} manifest - The application manifest
 * @returns {{error: string|null, command: Object|null}}
 */
export function parseFunctionStyle(
	[, name, argsString],
	context = {},
	manifest,
) {
	const commandName = name.toLowerCase();

	// Find the command in manifest
	const command = manifest.commands.find(
		(cmd) => cmd.name.toLowerCase() === commandName,
	);
	if (!command) {
		return {
			error: `Unknown command: ${name}`,
			command: null,
		};
	}

	const parameters = command.parameters || {};
	const requiredParams = Object.entries(parameters)
		.filter(([_, p]) => p.required)
		.map(([name, param]) => ({ name, ...param }));
	const optionalParams = Object.entries(parameters)
		.filter(([_, p]) => !p.required)
		.map(([name, param]) => ({ name, ...param }));

	let args = {};
	const argPairs = argsString
		.split(',')
		.map((s) => s.trim())
		.filter(Boolean);

	let positionalIndex = 0;

	// Process arguments
	for (const argPair of argPairs) {
		if (argPair.includes('=')) {
			// Named parameter: key=value
			const [key, valueStr] = argPair.split('=', 2).map((s) => s.trim());
			if (!key || !valueStr) {
				return {
					error: `Invalid named parameter: ${argPair}`,
					command: null,
				};
			}

			// Validate parameter exists
			const paramName = Object.keys(parameters).find(
				(p) => p.toLowerCase() === key.toLowerCase(),
			);
			if (!paramName) {
				return {
					error: `Unknown parameter: ${key}`,
					command: null,
				};
			}

			const param = parameters[paramName];
			args[paramName] = ParserUtils.normalizeValue(valueStr);
		} else {
			// Positional parameter
			if (positionalIndex >= requiredParams.length) {
				return {
					error: `Unexpected positional parameter: ${argPair}. All required parameters already provided.`,
					command: null,
				};
			}

			const param = requiredParams[positionalIndex];
			args[param.name] = ParserUtils.normalizeValue(argPair);
			positionalIndex++;
		}
	}

	// Check for missing required parameters after applying runtime fallbacks
	const missingParams = [];
	for (const param of requiredParams) {
		if (!(param.name in args)) {
			// Try to apply runtime fallback
			if (
				param.runtimeFallback &&
				context &&
				context.state &&
				context.state.has(param.runtimeFallback)
			) {
				args[param.name] = context.state.get(param.runtimeFallback);
			} else {
				missingParams.push(param.name);
			}
		}
	}

	if (missingParams.length > 0) {
		return {
			error: `Missing required parameters: ${missingParams.join(',')}`,
			command: null,
		};
	}

	// Apply defaults
	for (const param of optionalParams) {
		if (!(param.name in args) && param.default !== undefined) {
			args[param.name] = param.default;
		}
	}

	// Validate arguments against manifest specs
	for (const paramName in parameters) {
		const param = parameters[paramName];
		const value = args[paramName];
		if (value === undefined && !param.required) continue;

		// Type validation for union types
		const types = param.type.split('|').map((t) => t.trim());
		let parsedValue = value;
		let typeValidationPassed = false;

		// Try each type in the union until one succeeds
		for (const type of types) {
			try {
				if (type === 'integer') {
					const intValue = parseInt(value, 10);
					if (!isNaN(intValue)) {
						parsedValue = intValue;
						typeValidationPassed = true;
						break;
					}
				} else if (type === 'number') {
					const numValue = parseFloat(value);
					if (!isNaN(numValue)) {
						parsedValue = numValue;
						typeValidationPassed = true;
						break;
					}
				} else if (type === 'boolean') {
					if (typeof value === 'boolean') {
						parsedValue = value;
						typeValidationPassed = true;
						break;
					} else {
						const lowerValue = value.toLowerCase();
						if (lowerValue === 'true') {
							parsedValue = true;
							typeValidationPassed = true;
							break;
						} else if (lowerValue === 'false') {
							parsedValue = false;
							typeValidationPassed = true;
							break;
						}
					}
				} else if (type === 'array') {
					if (Array.isArray(value)) {
						parsedValue = value;
						typeValidationPassed = true;
						break;
					} else {
						try {
							const arrayValue = JSON.parse(value);
							if (Array.isArray(arrayValue)) {
								parsedValue = arrayValue;
								typeValidationPassed = true;
								break;
							}
						} catch {
							// Continue to next type
						}
					}
				} else if (type === 'string') {
					// Strings are always valid (everything can be treated as a string)
					parsedValue = String(value);
					typeValidationPassed = true;
					break;
				}
			} catch {
				// Continue to next type if this one fails
				continue;
			}
		}

		// If no type validation passed, return error
		if (!typeValidationPassed) {
			return {
				error: `Parameter ${paramName} must be of type: ${param.type}`,
				command: null,
			};
		}

		// Update args with parsed value
		args[paramName] = parsedValue;

		// Range validation for numbers
		if (types.includes('integer') || types.includes('number')) {
			if (param.min !== undefined && parsedValue < param.min) {
				return {
					error: `Parameter ${paramName} must be at least ${param.min}`,
					command: null,
				};
			}
			if (param.max !== undefined && parsedValue > param.max) {
				return {
					error: `Parameter ${paramName} must be at most ${param.max}`,
					command: null,
				};
			}
		}

		// Enum validation
		if (param.enum && !param.enum.includes(parsedValue)) {
			return {
				error: `Parameter ${paramName} must be one of: ${param.enum.join(', ')}`,
				command: null,
			};
		}
	}

	return {
		error: null,
		command: {
			name: command.name,
			args,
		},
	};
}


================================================================================

// File: processor\parsers\Objective.js

import { ParserUtils } from './Utils.js';

/**
 * Parse a command in object style
 * @param {string[]} match - Destructured match from regex
 * @param {Object} context - Optional context with runtime state
 * @param {Object} manifest - The application manifest
 * @returns {{error: string|null, command: Object|null}}
 */
export function parseObjectStyle([, name, argsString], context = {}, manifest) {
	const commandName = name.toLowerCase();

	// Find the command in manifest
	const command = manifest.commands.find(
		(cmd) => cmd.name.toLowerCase() === commandName,
	);
	if (!command) {
		return {
			error: `Unknown command: ${name}`,
			command: null,
		};
	}

	const parameters = command.parameters || {};
	const requiredParams = Object.entries(parameters)
		.filter(([_, p]) => p.required)
		.map(([name, param]) => ({ name, ...param }));
	const optionalParams = Object.entries(parameters)
		.filter(([_, p]) => !p.required)
		.map(([name, param]) => ({ name, ...param }));

	let args;
	try {
		// Try parsing as JSON
		args = JSON.parse(argsString);
	} catch (e) {
		try {
			// Fallback: Convert JS object literal to JSON (add quotes around keys)
			const wrappedArgsString = argsString.replace(
				/([{,]\s*)([a-zA-Z_$][\w$]*)(\s*:)/g,
				'$1"$2"$3',
			);
			args = JSON.parse(wrappedArgsString);
		} catch (fallbackError) {
			return {
				error: `Invalid object syntax: ${argsString}`,
				command: null,
			};
		}
	}

	// Handle non-object inputs for parameters with transform rules
	if (typeof args !== 'object' || args === null) {
		const paramEntries = Object.entries(parameters);
		const singleParamEntry = paramEntries.find(
			([_, p]) => p.required && p.transform,
		);
		if (singleParamEntry) {
			const [paramName, singleParam] = singleParamEntry;
			const types = singleParam.type.split('|').map((t) => t.trim());
			let parsedValue = args;

			// Validate and parse type
			if (types.includes('integer') && !isNaN(parseInt(args, 10))) {
				parsedValue = parseInt(args, 10);
			} else if (types.includes('string')) {
				parsedValue = String(args);
			} else {
				return {
					error: `Parameter ${paramName} must be ${singleParam.type}`,
					command: null,
				};
			}

			// Apply transform rule from manifest
			if (singleParam.transform) {
				const isInteger =
					types.includes('integer') && Number.isInteger(parsedValue);
				args = isInteger
					? singleParam.transform.then
					: singleParam.transform.else;
				args[
					singleParam.transform.then.id || singleParam.transform.else.title
				] = parsedValue;
			} else {
				args = { [paramName]: parsedValue };
			}
		} else {
			return {
				error: `Expected object or single value for ${commandName} with transform`,
				command: null,
			};
		}
	}

	// Normalize arguments
	args = ParserUtils.normalizeArgs(args);

	// Validate parameters against manifest
	const validatedArgs = {};

	// Check for unknown parameters
	for (const key of Object.keys(args)) {
		const paramName = Object.keys(parameters).find(
			(p) => p.toLowerCase() === key.toLowerCase(),
		);
		if (!paramName) {
			return {
				error: `Unknown parameter: ${key}`,
				command: null,
			};
		}
	}

	// Validate and process each parameter
	for (const paramName in parameters) {
		const param = parameters[paramName];

		// Get current value, applying fallback if needed
		let value = args[paramName];
		if (
			value === undefined &&
			param.runtimeFallback &&
			context &&
			context.state &&
			context.state.has(param.runtimeFallback)
		) {
			value = context.state.get(param.runtimeFallback);
			args[paramName] = value; // Update args with fallback value
		}

		// Check for missing required parameters
		if (value === undefined && param.required) {
			return {
				error: `Missing required parameter: ${paramName}`,
				command: null,
			};
		}

		// Apply default for optional parameters
		if (value === undefined && !param.required && param.default !== undefined) {
			validatedArgs[paramName] = param.default;
			continue;
		}

		if (value === undefined) continue;

		// Type validation
		const types = param.type.split('|').map((t) => t.trim());
		let parsedValue = value;

		if (types.includes('integer')) {
			parsedValue = parseInt(value, 10);
			if (isNaN(parsedValue)) {
				return {
					error: `Parameter ${paramName} must be an integer`,
					command: null,
				};
			}
		} else if (types.includes('number')) {
			parsedValue = parseFloat(value);
			if (isNaN(parsedValue)) {
				return {
					error: `Parameter ${paramName} must be a number`,
					command: null,
				};
			}
		} else if (types.includes('boolean')) {
			if (typeof value !== 'boolean') {
				const lowerValue = String(value).toLowerCase();
				if (lowerValue === 'true') parsedValue = true;
				else if (lowerValue === 'false') parsedValue = false;
				else
					return {
						error: `Parameter ${paramName} must be a boolean (true/false)`,
						command: null,
					};
			}
		} else if (types.includes('array')) {
			if (!Array.isArray(value)) {
				try {
					parsedValue = JSON.parse(value);
					if (!Array.isArray(parsedValue)) throw new Error();
				} catch {
					return {
						error: `Parameter ${paramName} must be an array`,
						command: null,
					};
				}
			}
		} else if (types.includes('string')) {
			parsedValue = String(value);
		} else {
			return {
				error: `Unsupported type for ${paramName}: ${param.type}`,
				command: null,
			};
		}

		// Range validation for numbers
		if (types.includes('integer') || types.includes('number')) {
			if (param.min !== undefined && parsedValue < param.min) {
				return {
					error: `Parameter ${paramName} must be at least ${param.min}`,
					command: null,
				};
			}
			if (param.max !== undefined && parsedValue > param.max) {
				return {
					error: `Parameter ${paramName} must be at most ${param.max}`,
					command: null,
				};
			}
		}

		// Enum validation
		if (param.enum && !param.enum.includes(parsedValue)) {
			return {
				error: `Parameter ${paramName} must be one of: ${param.enum.join(', ')}`,
				command: null,
			};
		}

		validatedArgs[paramName] = parsedValue;
	}

	return {
		error: null,
		command: {
			name: command.name,
			args: validatedArgs,
		},
	};
}


================================================================================

// File: processor\parsers\Utils.js

export class ParserUtils {
	/**
	 * Normalize a single value
	 */
	static normalizeValue(value) {
		let result = value;

		if (typeof value === 'string') {
			const trimmed = value.trim();
			let unquoted = trimmed;

			if (
				(trimmed.startsWith('"') && trimmed.endsWith('"')) ||
				(trimmed.startsWith("'") && trimmed.endsWith("'"))
			) {
				unquoted = trimmed.slice(1, -1);
			}

			if (/^-?\d+$/.test(unquoted)) {
				result = parseInt(unquoted, 10);
			} else if (/^-?\d+\.\d+$/.test(unquoted)) {
				result = parseFloat(unquoted);
			} else if (unquoted === 'true') {
				result = true;
			} else if (unquoted === 'false') {
				result = false;
			} else if (unquoted !== trimmed) {
				result = unquoted;
			}
		}

		return result;
	}

	/**
	 * Split key=value pairs with quote handling
	 */
	static splitKeyValue(pair) {
		if (!pair.includes('=')) return [null, null];

		const eqIndex = pair.indexOf('=');
		const key = pair.slice(0, eqIndex).trim();
		const value = this.normalizeValue(pair.slice(eqIndex + 1).trim());

		return [key, value];
	}

	/**
	 * Normalize all values in an args object
	 */
	static normalizeArgs(args) {
		const result = {};
		for (const [key, value] of Object.entries(args)) {
			result[key] = this.normalizeValue(value);
		}
		return result;
	}

	/**
	 * Validate command has required positional arguments
	 */
	static validatePositionalArgs(args, requiredCount) {
		if (args.length < requiredCount) {
			throw new Error(`Requires at least ${requiredCount} arguments`);
		}
		for (let i = 0; i < requiredCount; i++) {
			if (args[i].includes('=')) {
				throw new Error(`Argument ${i + 1} must be positional`);
			}
		}
	}

	static isNullish(v) {
		return v === null || v === undefined || v === 'null';
	}
}


================================================================================

// File: utils\config-loader.js

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Validate that a resolved path doesn't escape the project root
 */
function validatePathSecurity(resolvedPath, projectRoot, originalPath) {
    // Ensure the resolved path is within the project root
    if (!resolvedPath.startsWith(projectRoot)) {
        throw new Error(
            `Security violation: Path '${originalPath}' resolves to '${resolvedPath}' ` +
            `which is outside project root '${projectRoot}'`
        );
    }
    return resolvedPath;
}

/**
 * Safely resolve a path relative to project root with security validation
 */
function resolveSecurePath(originalPath, projectRoot) {
    if (!originalPath) return null;
    
    const resolvedPath = path.resolve(projectRoot, originalPath);
    return validatePathSecurity(resolvedPath, projectRoot, originalPath);
}

/**
 * Load configuration from file
 */
function loadConfigFromFile(configFilePath) {
    if (!fs.existsSync(configFilePath)) {
        throw new Error(`Configuration file does not exist: ${configFilePath}`);
    }
    return JSON.parse(fs.readFileSync(configFilePath, 'utf8'));
}

/**
 * Deep merge objects
 */
function deepMerge(target, source) {
    const result = { ...target };
    
    for (const key in source) {
        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
            result[key] = deepMerge(target[key] || {}, source[key]);
        } else {
            result[key] = source[key];
        }
    }
    
    return result;
}

/**
 * Build plugin-specific config by merging global paths with plugin-specific paths
 */
function buildPluginConfig(globalConfig, pluginRawConfig) {
    // Start with plugin's non-path configuration
    const pluginConfig = { ...pluginRawConfig };
    
    // Merge paths: global paths + plugin-specific paths
    if (pluginRawConfig.paths) {
        pluginConfig.paths = deepMerge(
            { ...globalConfig.paths }, // Clone global paths
            pluginRawConfig.paths      // Plugin-specific paths
        );
        
        // RESOLVE PLUGIN-SPECIFIC PATHS HERE
        for (const [key, value] of Object.entries(pluginConfig.paths)) {
            // Skip if already resolved or is a function
            if (typeof value === 'string' && !value.startsWith(globalConfig.paths.projectRoot)) {
                try {
                    pluginConfig.paths[key] = resolveSecurePath(value, globalConfig.paths.projectRoot);
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Could not resolve plugin path ${key}: ${value}`, error.message);
                }
            }
        }
    } else {
        // If plugin has no paths, just use global paths
        pluginConfig.paths = { ...globalConfig.paths };
    }
    
    return pluginConfig;
}

/**
 * Build a complete configuration object with fully resolved paths and namespaced plugins
 */
export function buildConfig(configFilePath, projectRoot) {
    // Load raw kernel configuration
    const rawKernelConfig = loadConfigFromFile(configFilePath);

    // Calculate kernel directory (fixed relative to this file)
    const kernelDir = path.join(__dirname, '..');

    // Load plugin configurations by scanning the plugins directory
    const pluginConfigs = {};
    if (rawKernelConfig.paths?.pluginsDir) {
        const pluginsDir = resolveSecurePath(rawKernelConfig.paths.pluginsDir, projectRoot);
        
        // Scan the plugins directory for all plugin folders
        if (fs.existsSync(pluginsDir)) {
            try {
                const pluginDirs = fs.readdirSync(pluginsDir).filter(item => {
                    const itemPath = path.join(pluginsDir, item);
                    return fs.statSync(itemPath).isDirectory();
                });

                // Load config for each discovered plugin
                for (const pluginName of pluginDirs) {
                    const pluginConfigPath = path.join(pluginsDir, pluginName, 'config.json');
                    if (fs.existsSync(pluginConfigPath)) {
                        try {
                            const pluginRawConfig = JSON.parse(fs.readFileSync(pluginConfigPath, 'utf8'));
                            pluginConfigs[pluginName] = pluginRawConfig;
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è Could not load config for plugin ${pluginName}:`, error.message);
                        }
                    } else {
                        // Plugin exists but has no config - initialize empty
                        pluginConfigs[pluginName] = {};
                    }
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è Could not scan plugins directory ${pluginsDir}:`, error.message);
            }
        }
    }

    // Build global paths (resolve EVERY path against project root with security validation)
    const globalPaths = {};
    for (const [key, value] of Object.entries(rawKernelConfig.paths || {})) {
        globalPaths[key] = value ? resolveSecurePath(value, projectRoot) : null;
    }

    // Add kernel-calculated paths (these are safe by construction)
    globalPaths.projectRoot = projectRoot;
    globalPaths.kernelDir = kernelDir;
    globalPaths.configFilePath = configFilePath;

    // Add utility functions for dynamic paths (with security validation)
    globalPaths.getContractManifestPath = (commandName) => {
        if (!globalPaths.contractDir) return null;
        const manifestPath = path.join(globalPaths.contractDir, commandName, 'manifest.json');
        return validatePathSecurity(manifestPath, projectRoot, `contracts/${commandName}/manifest.json`);
    };
    
    globalPaths.getContractHandlerPath = (commandName) => {
        if (!globalPaths.contractDir) return null;
        const handlerPath = path.join(globalPaths.contractDir, commandName, 'handler.js');
        return validatePathSecurity(handlerPath, projectRoot, `contracts/${commandName}/handler.js`);
    };
    
    globalPaths.getUIFilePath = (filename = 'index.html') => {
        if (!globalPaths.generatedUIDir) return null;
        const uiPath = path.join(globalPaths.generatedUIDir, filename);
        return validatePathSecurity(uiPath, projectRoot, `generated-ui/${filename}`);
    };

    // Create global config with resolved paths
    const globalConfig = {
        ...rawKernelConfig,
        paths: globalPaths,
    };

    // Build namespaced plugin configs
    const namespacedPlugins = {};
    for (const [pluginName, pluginRawConfig] of Object.entries(pluginConfigs)) {
        // Normalize plugin names (convert generate-html to generateHtml)
        const normalizedName = pluginName.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
        namespacedPlugins[normalizedName] = buildPluginConfig(globalConfig, pluginRawConfig);
    }

    // Return complete config with namespaced plugins
    return {
        ...globalConfig,
        ...namespacedPlugins,
    };
}

================================================================================

// File: utils\PluginLoader.js

import fs from 'fs';
import path from 'path';
import { pathToFileURL } from 'url';

/**
 * PluginLoader - A dynamic plugin loader with caching capabilities
 * Similar to handler loading but for transport plugins like stdio, http, electron
 */
export class PluginLoader {
	constructor(pluginsBaseDir) {
		this.pluginCache = new Map(); // Cache plugins after loading
		this.pluginsBaseDir = pluginsBaseDir;
	}

	/**
	 * Get or load a plugin by name
	 * @param {string} pluginName - Name of the plugin to load (e.g., 'stdio', 'http', 'electron')
	 * @returns {Object|null} - The loaded plugin module or null if not found
	 */
	async getPlugin(pluginName) {
		// Check if plugin is already cached
		if (this.pluginCache.has(pluginName)) {
			return this.pluginCache.get(pluginName);
		}

		try {
			// Build the plugin file path
			const pluginPath = path.join(this.pluginsBaseDir, pluginName, 'index.js');

			// Check if the plugin file exists
			if (!fs.existsSync(pluginPath)) {
				console.warn(`Warning: Plugin not found at: ${pluginPath}`);
				return null;
			}

			// Convert to file URL for proper ES module loading
			const moduleUrl = pathToFileURL(pluginPath).href;

			// Dynamically import the plugin module
			const pluginModule = await import(moduleUrl);

			// Cache the plugin for future use
			this.pluginCache.set(pluginName, pluginModule);
			return pluginModule;
		} catch (error) {
			console.warn(
				`Warning: Could not load plugin ${pluginName}:`,
				error.message,
			);
			return null;
		}
	}

	/**
	 * Load and return a specific plugin method (start, run, etc.)
	 * @param {string} pluginName - Name of the plugin
	 * @param {string} methodName - Name of the method to extract (e.g., 'start', 'run')
	 * @returns {Function|null} - The requested method or null if not found
	 */
	async getPluginMethod(pluginName, methodName) {
		const plugin = await this.getPlugin(pluginName);

		if (!plugin) {
			return null;
		}

		const method = plugin[methodName];

		if (typeof method !== 'function') {
			console.warn(
				`Warning: Method '${methodName}' not found or is not a function in plugin '${pluginName}'`,
			);
			return null;
		}

		return method;
	}

	/**
	 * Discover all available plugins in the plugins directory
	 * @returns {string[]} - Array of plugin names
	 */
	discoverPlugins() {
		if (!fs.existsSync(this.pluginsBaseDir)) {
			console.warn(
				`Warning: Plugins directory does not exist: ${this.pluginsBaseDir}`,
			);
			return [];
		}

		const items = fs.readdirSync(this.pluginsBaseDir, { withFileTypes: true });
		const pluginNames = items
			.filter((dirent) => dirent.isDirectory())
			.map((dirent) => dirent.name);

		return pluginNames;
	}

	/**
	 * Get all discovered plugins with their metadata
	 * @returns {Object} - Object with plugin names as keys and metadata as values
	 */
	getAllPluginMetadata() {
		const pluginNames = this.discoverPlugins();
		const metadata = {};

		for (const pluginName of pluginNames) {
			const pluginDir = path.join(this.pluginsBaseDir, pluginName);
			const manifestPath = path.join(pluginDir, 'manifest.json');

			// Load plugin manifest if it exists
			if (fs.existsSync(manifestPath)) {
				try {
					const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
					metadata[pluginName] = {
						name: pluginName,
						manifest: manifest,
						hasConfig: fs.existsSync(path.join(pluginDir, 'config.json')),
					};
				} catch (error) {
					console.warn(
						`Warning: Could not load manifest for plugin ${pluginName}:`,
						error.message,
					);
					metadata[pluginName] = {
						name: pluginName,
						manifest: null,
						hasConfig: fs.existsSync(path.join(pluginDir, 'config.json')),
					};
				}
			} else {
				metadata[pluginName] = {
					name: pluginName,
					manifest: null,
					hasConfig: fs.existsSync(path.join(pluginDir, 'config.json')),
				};
			}
		}

		return metadata;
	}

	/**
	 * Reset the plugin cache (useful for development or reloading)
	 */
	clearCache() {
		this.pluginCache.clear();
	}

	/**
	 * Get cached plugin count
	 * @returns {number} - Number of cached plugins
	 */
	getCachedPluginCount() {
		return this.pluginCache.size;
	}

	/**
	 * Get list of cached plugin names
	 * @returns {string[]} - Array of cached plugin names
	 */
	getCachedPlugins() {
		return Array.from(this.pluginCache.keys());
	}
}

// Export the class only - consumers need to create instances with the pluginsDir
export default PluginLoader;


================================================================================

